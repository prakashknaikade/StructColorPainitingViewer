(function(){const l=document.createElement("link").relList;if(l&&l.supports&&l.supports("modulepreload"))return;for(const F of document.querySelectorAll('link[rel="modulepreload"]'))t(F);new MutationObserver(F=>{for(const V of F)if(V.type==="childList")for(const R of V.addedNodes)R.tagName==="LINK"&&R.rel==="modulepreload"&&t(R)}).observe(document,{childList:!0,subtree:!0});function U(F){const V={};return F.integrity&&(V.integrity=F.integrity),F.referrerPolicy&&(V.referrerPolicy=F.referrerPolicy),F.crossOrigin==="use-credentials"?V.credentials="include":F.crossOrigin==="anonymous"?V.credentials="omit":V.credentials="same-origin",V}function t(F){if(F.ep)return;F.ep=!0;const V=U(F);fetch(F.href,V)}})();class h{constructor(l=0,U=0,t=0){this.x=l,this.y=U,this.z=t}equals(l){return this.x===l.x&&this.y===l.y&&this.z===l.z}add(l){return typeof l=="number"?new h(this.x+l,this.y+l,this.z+l):new h(this.x+l.x,this.y+l.y,this.z+l.z)}subtract(l){return typeof l=="number"?new h(this.x-l,this.y-l,this.z-l):new h(this.x-l.x,this.y-l.y,this.z-l.z)}multiply(l){return typeof l=="number"?new h(this.x*l,this.y*l,this.z*l):new h(this.x*l.x,this.y*l.y,this.z*l.z)}lerp(l,U){return new h(this.x+(l.x-this.x)*U,this.y+(l.y-this.y)*U,this.z+(l.z-this.z)*U)}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}distanceTo(l){return Math.sqrt((this.x-l.x)**2+(this.y-l.y)**2+(this.z-l.z)**2)}normalize(){const l=this.length();return new h(this.x/l,this.y/l,this.z/l)}flat(){return[this.x,this.y,this.z]}clone(){return new h(this.x,this.y,this.z)}}class Y{constructor(l=0,U=0,t=0,F=1){this.x=l,this.y=U,this.z=t,this.w=F}equals(l){return this.x===l.x&&this.y===l.y&&this.z===l.z&&this.w===l.w}normalize(){const l=Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);return new Y(this.x/l,this.y/l,this.z/l,this.w/l)}multiply(l){const U=this.w,t=this.x,F=this.y,V=this.z,R=l.w,W=l.x,Q=l.y,Z=l.z;return new Y(U*W+t*R+F*Z-V*Q,U*Q-t*Z+F*R+V*W,U*Z+t*Q-F*W+V*R,U*R-t*W-F*Q-V*Z)}flat(){return[this.x,this.y,this.z,this.w]}clone(){return new Y(this.x,this.y,this.z,this.w)}static FromEuler(l){const U=l.x/2,t=l.y/2,F=l.z/2,V=Math.cos(t),R=Math.sin(t),W=Math.cos(U),Q=Math.sin(U),Z=Math.cos(F),d=Math.sin(F);return new Y(V*Q*Z+R*W*d,R*W*Z-V*Q*d,V*W*d-R*Q*Z,V*W*Z+R*Q*d)}toEuler(){const l=2*(this.w*this.x+this.y*this.z),U=1-2*(this.x*this.x+this.y*this.y),t=Math.atan2(l,U);let F;const V=2*(this.w*this.y-this.z*this.x);F=Math.abs(V)>=1?Math.sign(V)*Math.PI/2:Math.asin(V);const R=2*(this.w*this.z+this.x*this.y),W=1-2*(this.y*this.y+this.z*this.z),Q=Math.atan2(R,W);return new h(t,F,Q)}static FromMatrix3(l){const U=l.buffer,t=U[0]+U[4]+U[8];let F,V,R,W;if(t>0){const Q=.5/Math.sqrt(t+1);W=.25/Q,F=(U[7]-U[5])*Q,V=(U[2]-U[6])*Q,R=(U[3]-U[1])*Q}else if(U[0]>U[4]&&U[0]>U[8]){const Q=2*Math.sqrt(1+U[0]-U[4]-U[8]);W=(U[7]-U[5])/Q,F=.25*Q,V=(U[1]+U[3])/Q,R=(U[2]+U[6])/Q}else if(U[4]>U[8]){const Q=2*Math.sqrt(1+U[4]-U[0]-U[8]);W=(U[2]-U[6])/Q,F=(U[1]+U[3])/Q,V=.25*Q,R=(U[5]+U[7])/Q}else{const Q=2*Math.sqrt(1+U[8]-U[0]-U[4]);W=(U[3]-U[1])/Q,F=(U[2]+U[6])/Q,V=(U[5]+U[7])/Q,R=.25*Q}return new Y(F,V,R,W)}}class QU{constructor(){const l=new Map;this.addEventListener=(U,t)=>{l.has(U)||l.set(U,new Set),l.get(U).add(t)},this.removeEventListener=(U,t)=>{l.has(U)&&l.get(U).delete(t)},this.hasEventListener=(U,t)=>!!l.has(U)&&l.get(U).has(t),this.dispatchEvent=U=>{if(l.has(U.type))for(const t of l.get(U.type))t(U)}}}class nU extends QU{constructor(){super(),this._position=new h,this._rotation=new Y,this._changeEvent={type:"change"}}get position(){return this._position}set position(l){this._position.equals(l)||(this._position=l,this.dispatchEvent(this._changeEvent))}get rotation(){return this._rotation}set rotation(l){this._rotation.equals(l)||(this._rotation=l,this.dispatchEvent(this._changeEvent))}}class G{constructor(l=1,U=0,t=0,F=0,V=1,R=0,W=0,Q=0,Z=1){this.buffer=[l,U,t,F,V,R,W,Q,Z]}equals(l){if(this.buffer.length!==l.buffer.length)return!1;if(this.buffer===l.buffer)return!0;for(let U=0;U<this.buffer.length;U++)if(this.buffer[U]!==l.buffer[U])return!1;return!0}multiply(l){const U=this.buffer,t=l.buffer;return new G(t[0]*U[0]+t[3]*U[1]+t[6]*U[2],t[1]*U[0]+t[4]*U[1]+t[7]*U[2],t[2]*U[0]+t[5]*U[1]+t[8]*U[2],t[0]*U[3]+t[3]*U[4]+t[6]*U[5],t[1]*U[3]+t[4]*U[4]+t[7]*U[5],t[2]*U[3]+t[5]*U[4]+t[8]*U[5],t[0]*U[6]+t[3]*U[7]+t[6]*U[8],t[1]*U[6]+t[4]*U[7]+t[7]*U[8],t[2]*U[6]+t[5]*U[7]+t[8]*U[8])}clone(){const l=this.buffer;return new G(l[0],l[1],l[2],l[3],l[4],l[5],l[6],l[7],l[8])}static Eye(l=1){return new G(l,0,0,0,l,0,0,0,l)}static Diagonal(l){return new G(l.x,0,0,0,l.y,0,0,0,l.z)}static RotationFromQuaternion(l){return new G(1-2*l.y*l.y-2*l.z*l.z,2*l.x*l.y-2*l.z*l.w,2*l.x*l.z+2*l.y*l.w,2*l.x*l.y+2*l.z*l.w,1-2*l.x*l.x-2*l.z*l.z,2*l.y*l.z-2*l.x*l.w,2*l.x*l.z-2*l.y*l.w,2*l.y*l.z+2*l.x*l.w,1-2*l.x*l.x-2*l.y*l.y)}static RotationFromEuler(l){const U=Math.cos(l.x),t=Math.sin(l.x),F=Math.cos(l.y),V=Math.sin(l.y),R=Math.cos(l.z),W=Math.sin(l.z);return new G(F*R+V*t*W,-F*W+V*t*R,V*U,U*W,U*R,-t,-V*R+F*t*W,V*W+F*t*R,F*U)}}class H{constructor(l=1,U=0,t=0,F=0,V=0,R=1,W=0,Q=0,Z=0,d=0,e=1,B=0,a=0,y=0,k=0,N=1){this.buffer=[l,U,t,F,V,R,W,Q,Z,d,e,B,a,y,k,N]}equals(l){if(this.buffer.length!==l.buffer.length)return!1;if(this.buffer===l.buffer)return!0;for(let U=0;U<this.buffer.length;U++)if(this.buffer[U]!==l.buffer[U])return!1;return!0}multiply(l){const U=this.buffer,t=l.buffer;return new H(t[0]*U[0]+t[1]*U[4]+t[2]*U[8]+t[3]*U[12],t[0]*U[1]+t[1]*U[5]+t[2]*U[9]+t[3]*U[13],t[0]*U[2]+t[1]*U[6]+t[2]*U[10]+t[3]*U[14],t[0]*U[3]+t[1]*U[7]+t[2]*U[11]+t[3]*U[15],t[4]*U[0]+t[5]*U[4]+t[6]*U[8]+t[7]*U[12],t[4]*U[1]+t[5]*U[5]+t[6]*U[9]+t[7]*U[13],t[4]*U[2]+t[5]*U[6]+t[6]*U[10]+t[7]*U[14],t[4]*U[3]+t[5]*U[7]+t[6]*U[11]+t[7]*U[15],t[8]*U[0]+t[9]*U[4]+t[10]*U[8]+t[11]*U[12],t[8]*U[1]+t[9]*U[5]+t[10]*U[9]+t[11]*U[13],t[8]*U[2]+t[9]*U[6]+t[10]*U[10]+t[11]*U[14],t[8]*U[3]+t[9]*U[7]+t[10]*U[11]+t[11]*U[15],t[12]*U[0]+t[13]*U[4]+t[14]*U[8]+t[15]*U[12],t[12]*U[1]+t[13]*U[5]+t[14]*U[9]+t[15]*U[13],t[12]*U[2]+t[13]*U[6]+t[14]*U[10]+t[15]*U[14],t[12]*U[3]+t[13]*U[7]+t[14]*U[11]+t[15]*U[15])}clone(){const l=this.buffer;return new H(l[0],l[1],l[2],l[3],l[4],l[5],l[6],l[7],l[8],l[9],l[10],l[11],l[12],l[13],l[14],l[15])}}class RU extends nU{constructor(l=new h(0,0,-5),U=new Y,t=1132,F=1132,V=.1,R=100){super();const W=()=>{const Q=G.RotationFromQuaternion(this.rotation).buffer,Z=this.position.flat(),d=[[Q[0],Q[1],Q[2],0],[Q[3],Q[4],Q[5],0],[Q[6],Q[7],Q[8],0],[-Z[0]*Q[0]-Z[1]*Q[3]-Z[2]*Q[6],-Z[0]*Q[1]-Z[1]*Q[4]-Z[2]*Q[7],-Z[0]*Q[2]-Z[1]*Q[5]-Z[2]*Q[8],1]].flat();return new H(...d)};this.position=l,this.rotation=U,this.fx=t,this.fy=F,this.near=V,this.far=R,this.projectionMatrix=new H,this.viewMatrix=new H,this.viewProj=new H,this.update=(Q,Z)=>{this.projectionMatrix=new H(2*this.fx/Q,0,0,0,0,-2*this.fy/Z,0,0,0,0,this.far/(this.far-this.near),1,0,0,-this.far*this.near/(this.far-this.near),0),this.viewMatrix=W(),this.viewProj=this.projectionMatrix.multiply(this.viewMatrix)}}}class D extends QU{constructor(){super();const l={type:"change"};this._vertexCount=0,this._positions=new Float32Array(0),this._rotations=new Float32Array(0),this._scales=new Float32Array(0),this._colors=new Uint8Array(0),this.setData=U=>{this._vertexCount=U.length/D.RowLength,this._positions=new Float32Array(3*this._vertexCount),this._rotations=new Float32Array(4*this._vertexCount),this._scales=new Float32Array(3*this._vertexCount),this._colors=new Uint8Array(4*this._vertexCount);const t=new Float32Array(U.buffer),F=new Uint8Array(U.buffer);for(let V=0;V<this._vertexCount;V++)this._positions[3*V+0]=t[8*V+0],this._positions[3*V+1]=t[8*V+1],this._positions[3*V+2]=t[8*V+2],this._rotations[4*V+0]=(F[32*V+28+0]-128)/128,this._rotations[4*V+1]=(F[32*V+28+1]-128)/128,this._rotations[4*V+2]=(F[32*V+28+2]-128)/128,this._rotations[4*V+3]=(F[32*V+28+3]-128)/128,this._scales[3*V+0]=t[8*V+3+0],this._scales[3*V+1]=t[8*V+3+1],this._scales[3*V+2]=t[8*V+3+2],this._colors[4*V+0]=F[32*V+24+0],this._colors[4*V+1]=F[32*V+24+1],this._colors[4*V+2]=F[32*V+24+2],this._colors[4*V+3]=F[32*V+24+3];this.dispatchEvent(l)},this.translate=U=>{for(let t=0;t<this._vertexCount;t++)this._positions[3*t+0]+=U.x,this._positions[3*t+1]+=U.y,this._positions[3*t+2]+=U.z;this.dispatchEvent(l)},this.rotate=U=>{const t=G.RotationFromQuaternion(U).buffer;for(let F=0;F<this._vertexCount;F++){const V=this._positions[3*F+0],R=this._positions[3*F+1],W=this._positions[3*F+2];this._positions[3*F+0]=t[0]*V+t[1]*R+t[2]*W,this._positions[3*F+1]=t[3]*V+t[4]*R+t[5]*W,this._positions[3*F+2]=t[6]*V+t[7]*R+t[8]*W;const Q=new Y(this._rotations[4*F+1],this._rotations[4*F+2],this._rotations[4*F+3],this._rotations[4*F+0]),Z=U.multiply(Q);this._rotations[4*F+1]=Z.x,this._rotations[4*F+2]=Z.y,this._rotations[4*F+3]=Z.z,this._rotations[4*F+0]=Z.w}this.dispatchEvent(l)},this.scale=U=>{for(let t=0;t<this.vertexCount;t++)this._positions[3*t+0]*=U.x,this._positions[3*t+1]*=U.y,this._positions[3*t+2]*=U.z,this._scales[3*t+0]*=U.x,this._scales[3*t+1]*=U.y,this._scales[3*t+2]*=U.z;this.dispatchEvent(l)},this.limitBox=(U,t,F,V,R,W)=>{if(U>=t)throw new Error(`xMin (${U}) must be smaller than xMax (${t})`);if(F>=V)throw new Error(`yMin (${F}) must be smaller than yMax (${V})`);if(R>=W)throw new Error(`zMin (${R}) must be smaller than zMax (${W})`);const Q=new Uint8Array(this._vertexCount);for(let d=0;d<this._vertexCount;d++){const e=this._positions[3*d+0],B=this._positions[3*d+1],a=this._positions[3*d+2];e>=U&&e<=t&&B>=F&&B<=V&&a>=R&&a<=W&&(Q[d]=1)}let Z=0;for(let d=0;d<this._vertexCount;d++)Q[d]!==0&&(this._positions[3*Z+0]=this._positions[3*d+0],this._positions[3*Z+1]=this._positions[3*d+1],this._positions[3*Z+2]=this._positions[3*d+2],this._rotations[4*Z+0]=this._rotations[4*d+0],this._rotations[4*Z+1]=this._rotations[4*d+1],this._rotations[4*Z+2]=this._rotations[4*d+2],this._rotations[4*Z+3]=this._rotations[4*d+3],this._scales[3*Z+0]=this._scales[3*d+0],this._scales[3*Z+1]=this._scales[3*d+1],this._scales[3*Z+2]=this._scales[3*d+2],this._colors[4*Z+0]=this._colors[4*d+0],this._colors[4*Z+1]=this._colors[4*d+1],this._colors[4*Z+2]=this._colors[4*d+2],this._colors[4*Z+3]=this._colors[4*d+3],Z+=1);this._vertexCount=Z,this._positions=new Float32Array(this._positions.buffer,0,3*Z),this._rotations=new Float32Array(this._rotations.buffer,0,4*Z),this._scales=new Float32Array(this._scales.buffer,0,3*Z),this._colors=new Uint8Array(this._colors.buffer,0,4*Z),this.dispatchEvent(l)},this.saveToFile=U=>{if(!document)return;const t=new Uint8Array(this._vertexCount*D.RowLength),F=new Float32Array(t.buffer),V=new Uint8Array(t.buffer);for(let Q=0;Q<this._vertexCount;Q++)F[8*Q+0]=this._positions[3*Q+0],F[8*Q+1]=this._positions[3*Q+1],F[8*Q+2]=this._positions[3*Q+2],V[32*Q+24+0]=this._colors[4*Q+0],V[32*Q+24+1]=this._colors[4*Q+1],V[32*Q+24+2]=this._colors[4*Q+2],V[32*Q+24+3]=this._colors[4*Q+3],F[8*Q+3+0]=this._scales[3*Q+0],F[8*Q+3+1]=this._scales[3*Q+1],F[8*Q+3+2]=this._scales[3*Q+2],V[32*Q+28+0]=128*this._rotations[4*Q+0]+128&255,V[32*Q+28+1]=128*this._rotations[4*Q+1]+128&255,V[32*Q+28+2]=128*this._rotations[4*Q+2]+128&255,V[32*Q+28+3]=128*this._rotations[4*Q+3]+128&255;const R=new Blob([t.buffer],{type:"application/octet-stream"}),W=document.createElement("a");W.download=U,W.href=URL.createObjectURL(R),W.click()}}get vertexCount(){return this._vertexCount}get positions(){return this._positions}get rotations(){return this._rotations}get scales(){return this._scales}get colors(){return this._colors}}D.RowLength=32;class WU{static async LoadAsync(l,U,t){const F=await fetch(l,{mode:"cors",credentials:"omit"});if(F.status!=200)throw new Error(F.status+" Unable to load "+F.url);const V=F.body.getReader(),R=parseInt(F.headers.get("content-length")),W=new Uint8Array(R);let Q=0;for(;;){const{done:Z,value:d}=await V.read();if(Z)break;W.set(d,Q),Q+=d.length,t==null||t(Q/R)}U.setData(W)}static async LoadFromFileAsync(l,U,t){const F=new FileReader;F.onload=V=>{const R=new Uint8Array(V.target.result);U.setData(R)},F.onprogress=V=>{t==null||t(V.loaded/V.total)},F.readAsArrayBuffer(l),await new Promise(V=>{F.onloadend=()=>{V()}})}}function eU(b,l,U){var t=l===void 0?null:l,F=function(Q,Z){var d=atob(Q);if(Z){for(var e=new Uint8Array(d.length),B=0,a=d.length;B<a;++B)e[B]=d.charCodeAt(B);return String.fromCharCode.apply(null,new Uint16Array(e.buffer))}return d}(b,U!==void 0&&U),V=F.indexOf(`
`,10)+1,R=F.substring(V)+(t?"//# sourceMappingURL="+t:""),W=new Blob([R],{type:"application/javascript"});return URL.createObjectURL(W)}var $,UU,FU,P,BU=($="Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwooZnVuY3Rpb24gKCkgewogICd1c2Ugc3RyaWN0JzsKCiAgdmFyIGxvYWRXYXNtID0gKCgpID0+IHsKICAgIAogICAgcmV0dXJuICgKICBmdW5jdGlvbihtb2R1bGVBcmcgPSB7fSkgewoKICB2YXIgTW9kdWxlPW1vZHVsZUFyZzt2YXIgcmVhZHlQcm9taXNlUmVzb2x2ZSxyZWFkeVByb21pc2VSZWplY3Q7TW9kdWxlWyJyZWFkeSJdPW5ldyBQcm9taXNlKChyZXNvbHZlLHJlamVjdCk9PntyZWFkeVByb21pc2VSZXNvbHZlPXJlc29sdmU7cmVhZHlQcm9taXNlUmVqZWN0PXJlamVjdDt9KTt2YXIgbW9kdWxlT3ZlcnJpZGVzPU9iamVjdC5hc3NpZ24oe30sTW9kdWxlKTt2YXIgc2NyaXB0RGlyZWN0b3J5PSIiO2Z1bmN0aW9uIGxvY2F0ZUZpbGUocGF0aCl7aWYoTW9kdWxlWyJsb2NhdGVGaWxlIl0pe3JldHVybiBNb2R1bGVbImxvY2F0ZUZpbGUiXShwYXRoLHNjcmlwdERpcmVjdG9yeSl9cmV0dXJuIHNjcmlwdERpcmVjdG9yeStwYXRofXZhciByZWFkQmluYXJ5O3t7c2NyaXB0RGlyZWN0b3J5PXNlbGYubG9jYXRpb24uaHJlZjt9aWYoc2NyaXB0RGlyZWN0b3J5LmluZGV4T2YoImJsb2I6IikhPT0wKXtzY3JpcHREaXJlY3Rvcnk9c2NyaXB0RGlyZWN0b3J5LnN1YnN0cigwLHNjcmlwdERpcmVjdG9yeS5yZXBsYWNlKC9bPyNdLiovLCIiKS5sYXN0SW5kZXhPZigiLyIpKzEpO31lbHNlIHtzY3JpcHREaXJlY3Rvcnk9IiI7fXt7cmVhZEJpbmFyeT11cmw9Pnt2YXIgeGhyPW5ldyBYTUxIdHRwUmVxdWVzdDt4aHIub3BlbigiR0VUIix1cmwsZmFsc2UpO3hoci5yZXNwb25zZVR5cGU9ImFycmF5YnVmZmVyIjt4aHIuc2VuZChudWxsKTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoeGhyLnJlc3BvbnNlKX07fX19TW9kdWxlWyJwcmludCJdfHxjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO3ZhciBlcnI9TW9kdWxlWyJwcmludEVyciJdfHxjb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSk7T2JqZWN0LmFzc2lnbihNb2R1bGUsbW9kdWxlT3ZlcnJpZGVzKTttb2R1bGVPdmVycmlkZXM9bnVsbDtpZihNb2R1bGVbImFyZ3VtZW50cyJdKU1vZHVsZVsiYXJndW1lbnRzIl07aWYoTW9kdWxlWyJ0aGlzUHJvZ3JhbSJdKU1vZHVsZVsidGhpc1Byb2dyYW0iXTtpZihNb2R1bGVbInF1aXQiXSlNb2R1bGVbInF1aXQiXTt2YXIgd2FzbUJpbmFyeTtpZihNb2R1bGVbIndhc21CaW5hcnkiXSl3YXNtQmluYXJ5PU1vZHVsZVsid2FzbUJpbmFyeSJdO2lmKHR5cGVvZiBXZWJBc3NlbWJseSE9Im9iamVjdCIpe2Fib3J0KCJubyBuYXRpdmUgd2FzbSBzdXBwb3J0IGRldGVjdGVkIik7fWZ1bmN0aW9uIGludEFycmF5RnJvbUJhc2U2NChzKXt2YXIgZGVjb2RlZD1hdG9iKHMpO3ZhciBieXRlcz1uZXcgVWludDhBcnJheShkZWNvZGVkLmxlbmd0aCk7Zm9yKHZhciBpPTA7aTxkZWNvZGVkLmxlbmd0aDsrK2kpe2J5dGVzW2ldPWRlY29kZWQuY2hhckNvZGVBdChpKTt9cmV0dXJuIGJ5dGVzfWZ1bmN0aW9uIHRyeVBhcnNlQXNEYXRhVVJJKGZpbGVuYW1lKXtpZighaXNEYXRhVVJJKGZpbGVuYW1lKSl7cmV0dXJufXJldHVybiBpbnRBcnJheUZyb21CYXNlNjQoZmlsZW5hbWUuc2xpY2UoZGF0YVVSSVByZWZpeC5sZW5ndGgpKX12YXIgd2FzbU1lbW9yeTt2YXIgQUJPUlQ9ZmFsc2U7dmFyIEhFQVA4LEhFQVBVOCxIRUFQMTYsSEVBUFUxNixIRUFQMzIsSEVBUFUzMixIRUFQRjMyLEhFQVBGNjQ7ZnVuY3Rpb24gdXBkYXRlTWVtb3J5Vmlld3MoKXt2YXIgYj13YXNtTWVtb3J5LmJ1ZmZlcjtNb2R1bGVbIkhFQVA4Il09SEVBUDg9bmV3IEludDhBcnJheShiKTtNb2R1bGVbIkhFQVAxNiJdPUhFQVAxNj1uZXcgSW50MTZBcnJheShiKTtNb2R1bGVbIkhFQVBVOCJdPUhFQVBVOD1uZXcgVWludDhBcnJheShiKTtNb2R1bGVbIkhFQVBVMTYiXT1IRUFQVTE2PW5ldyBVaW50MTZBcnJheShiKTtNb2R1bGVbIkhFQVAzMiJdPUhFQVAzMj1uZXcgSW50MzJBcnJheShiKTtNb2R1bGVbIkhFQVBVMzIiXT1IRUFQVTMyPW5ldyBVaW50MzJBcnJheShiKTtNb2R1bGVbIkhFQVBGMzIiXT1IRUFQRjMyPW5ldyBGbG9hdDMyQXJyYXkoYik7TW9kdWxlWyJIRUFQRjY0Il09SEVBUEY2ND1uZXcgRmxvYXQ2NEFycmF5KGIpO312YXIgX19BVFBSRVJVTl9fPVtdO3ZhciBfX0FUSU5JVF9fPVtdO3ZhciBfX0FUUE9TVFJVTl9fPVtdO2Z1bmN0aW9uIHByZVJ1bigpe2lmKE1vZHVsZVsicHJlUnVuIl0pe2lmKHR5cGVvZiBNb2R1bGVbInByZVJ1biJdPT0iZnVuY3Rpb24iKU1vZHVsZVsicHJlUnVuIl09W01vZHVsZVsicHJlUnVuIl1dO3doaWxlKE1vZHVsZVsicHJlUnVuIl0ubGVuZ3RoKXthZGRPblByZVJ1bihNb2R1bGVbInByZVJ1biJdLnNoaWZ0KCkpO319Y2FsbFJ1bnRpbWVDYWxsYmFja3MoX19BVFBSRVJVTl9fKTt9ZnVuY3Rpb24gaW5pdFJ1bnRpbWUoKXtjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUSU5JVF9fKTt9ZnVuY3Rpb24gcG9zdFJ1bigpe2lmKE1vZHVsZVsicG9zdFJ1biJdKXtpZih0eXBlb2YgTW9kdWxlWyJwb3N0UnVuIl09PSJmdW5jdGlvbiIpTW9kdWxlWyJwb3N0UnVuIl09W01vZHVsZVsicG9zdFJ1biJdXTt3aGlsZShNb2R1bGVbInBvc3RSdW4iXS5sZW5ndGgpe2FkZE9uUG9zdFJ1bihNb2R1bGVbInBvc3RSdW4iXS5zaGlmdCgpKTt9fWNhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRQT1NUUlVOX18pO31mdW5jdGlvbiBhZGRPblByZVJ1bihjYil7X19BVFBSRVJVTl9fLnVuc2hpZnQoY2IpO31mdW5jdGlvbiBhZGRPbkluaXQoY2Ipe19fQVRJTklUX18udW5zaGlmdChjYik7fWZ1bmN0aW9uIGFkZE9uUG9zdFJ1bihjYil7X19BVFBPU1RSVU5fXy51bnNoaWZ0KGNiKTt9dmFyIHJ1bkRlcGVuZGVuY2llcz0wO3ZhciBkZXBlbmRlbmNpZXNGdWxmaWxsZWQ9bnVsbDtmdW5jdGlvbiBhZGRSdW5EZXBlbmRlbmN5KGlkKXtydW5EZXBlbmRlbmNpZXMrKztpZihNb2R1bGVbIm1vbml0b3JSdW5EZXBlbmRlbmNpZXMiXSl7TW9kdWxlWyJtb25pdG9yUnVuRGVwZW5kZW5jaWVzIl0ocnVuRGVwZW5kZW5jaWVzKTt9fWZ1bmN0aW9uIHJlbW92ZVJ1bkRlcGVuZGVuY3koaWQpe3J1bkRlcGVuZGVuY2llcy0tO2lmKE1vZHVsZVsibW9uaXRvclJ1bkRlcGVuZGVuY2llcyJdKXtNb2R1bGVbIm1vbml0b3JSdW5EZXBlbmRlbmNpZXMiXShydW5EZXBlbmRlbmNpZXMpO31pZihydW5EZXBlbmRlbmNpZXM9PTApe2lmKGRlcGVuZGVuY2llc0Z1bGZpbGxlZCl7dmFyIGNhbGxiYWNrPWRlcGVuZGVuY2llc0Z1bGZpbGxlZDtkZXBlbmRlbmNpZXNGdWxmaWxsZWQ9bnVsbDtjYWxsYmFjaygpO319fWZ1bmN0aW9uIGFib3J0KHdoYXQpe2lmKE1vZHVsZVsib25BYm9ydCJdKXtNb2R1bGVbIm9uQWJvcnQiXSh3aGF0KTt9d2hhdD0iQWJvcnRlZCgiK3doYXQrIikiO2Vycih3aGF0KTtBQk9SVD10cnVlO3doYXQrPSIuIEJ1aWxkIHdpdGggLXNBU1NFUlRJT05TIGZvciBtb3JlIGluZm8uIjt2YXIgZT1uZXcgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yKHdoYXQpO3JlYWR5UHJvbWlzZVJlamVjdChlKTt0aHJvdyBlfXZhciBkYXRhVVJJUHJlZml4PSJkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsIjt2YXIgaXNEYXRhVVJJPWZpbGVuYW1lPT5maWxlbmFtZS5zdGFydHNXaXRoKGRhdGFVUklQcmVmaXgpO3ZhciB3YXNtQmluYXJ5RmlsZTt3YXNtQmluYXJ5RmlsZT0iZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LEFHRnpiUUVBQUFBQlRneGdCSDkvZjM4QVlBTi9mMzhBWUFWL2YzOS9md0JnQm45L2YzOS9md0JnQVg4QmYyQUNmMzhBWUFOL2YzOEJmMkFCZndCZ0IzOS9mMzkvZjM4QVlBQUFZQUovZndGL1lBUi9mMzUrQUFJOUNnRmhBV0VBQVFGaEFXSUFBZ0ZoQVdNQUFRRmhBV1FBQlFGaEFXVUFBUUZoQVdZQUNBRmhBV2NBQkFGaEFXZ0FCUUZoQVdrQUFBRmhBV29BQlFNWkdBWUVCd2tIQndvTENRRUFBUVFFQXdNQ0FnQUFDZ1lHQ0FRRkFYQUJFQkFGQndFQmdBS0FnQUlHQ0FGL0FVSEFuZ1FMQnhrR0FXc0NBQUZzQUEwQmJRQWhBVzRCQUFGdkFCY0JjQUFQQ1JVQkFFRUJDdzhTRmd3T0RpQU1IeGdhSFF3Wkd4d0sxVWNZY1FFQmZ5QUNSUVJBSUFBb0FnUWdBU2dDQkVZUEN5QUFJQUZHQkVCQkFROExBa0FnQUNnQ0JDSUNMUUFBSWdCRklBQWdBU2dDQkNJQkxRQUFJZ05IY2cwQUEwQWdBUzBBQVNFRElBSXRBQUVpQUVVTkFTQUJRUUZxSVFFZ0FrRUJhaUVDSUFBZ0EwWU5BQXNMSUFBZ0EwWUxUd0VDZjBHNEdpZ0NBQ0lCSUFCQkIycEJlSEVpQW1vaEFBSkFJQUpCQUNBQUlBRk5HdzBBSUFBL0FFRVFkRXNFUUNBQUVBWkZEUUVMUWJnYUlBQTJBZ0FnQVE4TFFjZ2FRVEEyQWdCQmZ3c0dBQ0FBRUE4TEtRQkJ3QnBCQVRZQ0FFSEVHa0VBTmdJQUVCSkJ4QnBCdkJvb0FnQTJBZ0JCdkJwQndCbzJBZ0FMQWdBTDBnc0JCMzhDUUNBQVJRMEFJQUJCQ0dzaUFpQUFRUVJyS0FJQUlnRkJlSEVpQUdvaEJRSkFJQUZCQVhFTkFDQUJRUU54UlEwQklBSWdBaWdDQUNJQmF5SUNRZHdhS0FJQVNRMEJJQUFnQVdvaEFBSkFBa0JCNEJvb0FnQWdBa2NFUUNBQlFmOEJUUVJBSUFGQkEzWWhCQ0FDS0FJTUlnRWdBaWdDQ0NJRFJnUkFRY3dhUWN3YUtBSUFRWDRnQkhkeE5nSUFEQVVMSUFNZ0FUWUNEQ0FCSUFNMkFnZ01CQXNnQWlnQ0dDRUdJQUlnQWlnQ0RDSUJSd1JBSUFJb0FnZ2lBeUFCTmdJTUlBRWdBellDQ0F3REN5QUNRUlJxSWdRb0FnQWlBMFVFUUNBQ0tBSVFJZ05GRFFJZ0FrRVFhaUVFQ3dOQUlBUWhCeUFESWdGQkZHb2lCQ2dDQUNJRERRQWdBVUVRYWlFRUlBRW9BaEFpQXcwQUN5QUhRUUEyQWdBTUFnc2dCU2dDQkNJQlFRTnhRUU5IRFFKQjFCb2dBRFlDQUNBRklBRkJmbkUyQWdRZ0FpQUFRUUZ5TmdJRUlBVWdBRFlDQUE4TFFRQWhBUXNnQmtVTkFBSkFJQUlvQWh3aUEwRUNkRUg4SEdvaUJDZ0NBQ0FDUmdSQUlBUWdBVFlDQUNBQkRRRkIwQnBCMEJvb0FnQkJmaUFEZDNFMkFnQU1BZ3NnQmtFUVFSUWdCaWdDRUNBQ1JodHFJQUUyQWdBZ0FVVU5BUXNnQVNBR05nSVlJQUlvQWhBaUF3UkFJQUVnQXpZQ0VDQURJQUUyQWhnTElBSW9BaFFpQTBVTkFDQUJJQU0yQWhRZ0F5QUJOZ0lZQ3lBQ0lBVlBEUUFnQlNnQ0JDSUJRUUZ4UlEwQUFrQUNRQUpBQWtBZ0FVRUNjVVVFUUVIa0dpZ0NBQ0FGUmdSQVFlUWFJQUkyQWdCQjJCcEIyQm9vQWdBZ0FHb2lBRFlDQUNBQ0lBQkJBWEkyQWdRZ0FrSGdHaWdDQUVjTkJrSFVHa0VBTmdJQVFlQWFRUUEyQWdBUEMwSGdHaWdDQUNBRlJnUkFRZUFhSUFJMkFnQkIxQnBCMUJvb0FnQWdBR29pQURZQ0FDQUNJQUJCQVhJMkFnUWdBQ0FDYWlBQU5nSUFEd3NnQVVGNGNTQUFhaUVBSUFGQi93Rk5CRUFnQVVFRGRpRUVJQVVvQWd3aUFTQUZLQUlJSWdOR0JFQkJ6QnBCekJvb0FnQkJmaUFFZDNFMkFnQU1CUXNnQXlBQk5nSU1JQUVnQXpZQ0NBd0VDeUFGS0FJWUlRWWdCU0FGS0FJTUlnRkhCRUJCM0Jvb0FnQWFJQVVvQWdnaUF5QUJOZ0lNSUFFZ0F6WUNDQXdEQ3lBRlFSUnFJZ1FvQWdBaUEwVUVRQ0FGS0FJUUlnTkZEUUlnQlVFUWFpRUVDd05BSUFRaEJ5QURJZ0ZCRkdvaUJDZ0NBQ0lERFFBZ0FVRVFhaUVFSUFFb0FoQWlBdzBBQ3lBSFFRQTJBZ0FNQWdzZ0JTQUJRWDV4TmdJRUlBSWdBRUVCY2pZQ0JDQUFJQUpxSUFBMkFnQU1Bd3RCQUNFQkN5QUdSUTBBQWtBZ0JTZ0NIQ0lEUVFKMFFmd2NhaUlFS0FJQUlBVkdCRUFnQkNBQk5nSUFJQUVOQVVIUUdrSFFHaWdDQUVGK0lBTjNjVFlDQUF3Q0N5QUdRUkJCRkNBR0tBSVFJQVZHRzJvZ0FUWUNBQ0FCUlEwQkN5QUJJQVkyQWhnZ0JTZ0NFQ0lEQkVBZ0FTQUROZ0lRSUFNZ0FUWUNHQXNnQlNnQ0ZDSURSUTBBSUFFZ0F6WUNGQ0FESUFFMkFoZ0xJQUlnQUVFQmNqWUNCQ0FBSUFKcUlBQTJBZ0FnQWtIZ0dpZ0NBRWNOQUVIVUdpQUFOZ0lBRHdzZ0FFSC9BVTBFUUNBQVFYaHhRZlFhYWlFQkFuOUJ6Qm9vQWdBaUEwRUJJQUJCQTNaMElnQnhSUVJBUWN3YUlBQWdBM0kyQWdBZ0FRd0JDeUFCS0FJSUN5RUFJQUVnQWpZQ0NDQUFJQUkyQWd3Z0FpQUJOZ0lNSUFJZ0FEWUNDQThMUVI4aEF5QUFRZi8vL3dkTkJFQWdBRUVtSUFCQkNIWm5JZ0ZyZGtFQmNTQUJRUUYwYTBFK2FpRURDeUFDSUFNMkFod2dBa0lBTndJUUlBTkJBblJCL0J4cUlRRUNRQUpBQWtCQjBCb29BZ0FpQkVFQklBTjBJZ2R4UlFSQVFkQWFJQVFnQjNJMkFnQWdBU0FDTmdJQUlBSWdBVFlDR0F3QkN5QUFRUmtnQTBFQmRtdEJBQ0FEUVI5SEczUWhBeUFCS0FJQUlRRURRQ0FCSWdRb0FnUkJlSEVnQUVZTkFpQURRUjEySVFFZ0EwRUJkQ0VESUFRZ0FVRUVjV29pQjBFUWFpZ0NBQ0lCRFFBTElBY2dBallDRUNBQ0lBUTJBaGdMSUFJZ0FqWUNEQ0FDSUFJMkFnZ01BUXNnQkNnQ0NDSUFJQUkyQWd3Z0JDQUNOZ0lJSUFKQkFEWUNHQ0FDSUFRMkFnd2dBaUFBTmdJSUMwSHNHa0hzR2lnQ0FFRUJheUlBUVg4Z0FCczJBZ0FMQ3lrQkFYOGdBUVJBSUFBaEFnTkFJQUpCQURvQUFDQUNRUUZxSVFJZ0FVRUJheUlCRFFBTEN5QUFDeHdBSUFBZ0FVRUlJQUtuSUFKQ0lJaW5JQU9uSUFOQ0lJaW5FQVVMNFFNQVFld1hRWm9KRUFsQitCZEJ1UWhCQVVFQUVBaEJoQmhCdEFoQkFVR0FmMEgvQUJBQlFad1lRYTBJUVFGQmdIOUIvd0FRQVVHUUdFR3JDRUVCUVFCQi93RVFBVUdvR0VHSkNFRUNRWUNBZmtILy93RVFBVUcwR0VHQUNFRUNRUUJCLy84REVBRkJ3QmhCbUFoQkJFR0FnSUNBZUVILy8vLy9CeEFCUWN3WVFZOElRUVJCQUVGL0VBRkIyQmhCMXdoQkJFR0FnSUNBZUVILy8vLy9CeEFCUWVRWVFjNElRUVJCQUVGL0VBRkI4QmhCb3doQ2dJQ0FnSUNBZ0lDQWYwTC8vLy8vLy8vLy8vOEFFQkZCL0JoQm9naENBRUovRUJGQmlCbEJuQWhCQkJBRVFaUVpRWk1KUVFnUUJFR0VEMEhwQ0JBRFFjd1BRWmNORUFOQmxCQkJCRUhjQ0JBQ1FlQVFRUUpCOVFnUUFrR3NFVUVFUVlRSkVBSkJ5QkZCdmdnUUIwSHdFVUVBUWRJTUVBQkJtQkpCQUVHNERSQUFRY0FTUVFGQjhBd1FBRUhvRWtFQ1FaOEpFQUJCa0JOQkEwRytDUkFBUWJnVFFRUkI1Z2tRQUVIZ0UwRUZRWU1LRUFCQmlCUkJCRUhkRFJBQVFiQVVRUVZCK3cwUUFFR1lFa0VBUWVrS0VBQkJ3QkpCQVVISUNoQUFRZWdTUVFKQnF3c1FBRUdRRTBFRFFZa0xFQUJCdUJOQkJFR3hEQkFBUWVBVFFRVkJqd3dRQUVIWUZFRUlRZTRMRUFCQmdCVkJDVUhNQ3hBQVFhZ1ZRUVpCcVFvUUFFSFFGVUVIUWFJT0VBQUxJQUFDUUNBQUtBSUVJQUZIRFFBZ0FDZ0NIRUVCUmcwQUlBQWdBallDSEFzTG1nRUFJQUJCQVRvQU5RSkFJQUFvQWdRZ0FrY05BQ0FBUVFFNkFEUUNRQ0FBS0FJUUlnSkZCRUFnQUVFQk5nSWtJQUFnQXpZQ0dDQUFJQUUyQWhBZ0EwRUJSdzBDSUFBb0FqQkJBVVlOQVF3Q0N5QUJJQUpHQkVBZ0FDZ0NHQ0lDUVFKR0JFQWdBQ0FETmdJWUlBTWhBZ3NnQUNnQ01FRUJSdzBDSUFKQkFVWU5BUXdDQ3lBQUlBQW9BaVJCQVdvMkFpUUxJQUJCQVRvQU5nc0xYUUVCZnlBQUtBSVFJZ05GQkVBZ0FFRUJOZ0lrSUFBZ0FqWUNHQ0FBSUFFMkFoQVBDd0pBSUFFZ0EwWUVRQ0FBS0FJWVFRSkhEUUVnQUNBQ05nSVlEd3NnQUVFQk9nQTJJQUJCQWpZQ0dDQUFJQUFvQWlSQkFXbzJBaVFMQ3dRQUlBQUx4U2NCREg4akFFRVFheUlLSkFBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBZ0FFSDBBVTBFUUVITUdpZ0NBQ0lHUVJBZ0FFRUxha0Y0Y1NBQVFRdEpHeUlGUVFOMklnQjJJZ0ZCQTNFRVFBSkFJQUZCZjNOQkFYRWdBR29pQWtFRGRDSUJRZlFhYWlJQUlBRkIvQnBxS0FJQUlnRW9BZ2dpQTBZRVFFSE1HaUFHUVg0Z0FuZHhOZ0lBREFFTElBTWdBRFlDRENBQUlBTTJBZ2dMSUFGQkNHb2hBQ0FCSUFKQkEzUWlBa0VEY2pZQ0JDQUJJQUpxSWdFZ0FTZ0NCRUVCY2pZQ0JBd0tDeUFGUWRRYUtBSUFJZ2RORFFFZ0FRUkFBa0JCQWlBQWRDSUNRUUFnQW10eUlBRWdBSFJ4YUNJQlFRTjBJZ0JCOUJwcUlnSWdBRUg4R21vb0FnQWlBQ2dDQ0NJRFJnUkFRY3dhSUFaQmZpQUJkM0VpQmpZQ0FBd0JDeUFESUFJMkFnd2dBaUFETmdJSUN5QUFJQVZCQTNJMkFnUWdBQ0FGYWlJRUlBRkJBM1FpQVNBRmF5SURRUUZ5TmdJRUlBQWdBV29nQXpZQ0FDQUhCRUFnQjBGNGNVSDBHbW9oQVVIZ0dpZ0NBQ0VDQW44Z0JrRUJJQWRCQTNaMElnVnhSUVJBUWN3YUlBVWdCbkkyQWdBZ0FRd0JDeUFCS0FJSUN5RUZJQUVnQWpZQ0NDQUZJQUkyQWd3Z0FpQUJOZ0lNSUFJZ0JUWUNDQXNnQUVFSWFpRUFRZUFhSUFRMkFnQkIxQm9nQXpZQ0FBd0tDMEhRR2lnQ0FDSUxSUTBCSUF0b1FRSjBRZndjYWlnQ0FDSUNLQUlFUVhoeElBVnJJUVFnQWlFQkEwQUNRQ0FCS0FJUUlnQkZCRUFnQVNnQ0ZDSUFSUTBCQ3lBQUtBSUVRWGh4SUFWcklnRWdCQ0FCSUFSSklnRWJJUVFnQUNBQ0lBRWJJUUlnQUNFQkRBRUxDeUFDS0FJWUlRa2dBaUFDS0FJTUlnTkhCRUJCM0Jvb0FnQWFJQUlvQWdnaUFDQUROZ0lNSUFNZ0FEWUNDQXdKQ3lBQ1FSUnFJZ0VvQWdBaUFFVUVRQ0FDS0FJUUlnQkZEUU1nQWtFUWFpRUJDd05BSUFFaENDQUFJZ05CRkdvaUFTZ0NBQ0lBRFFBZ0EwRVFhaUVCSUFNb0FoQWlBQTBBQ3lBSVFRQTJBZ0FNQ0F0QmZ5RUZJQUJCdjM5TERRQWdBRUVMYWlJQVFYaHhJUVZCMEJvb0FnQWlDRVVOQUVFQUlBVnJJUVFDUUFKQUFrQUNmMEVBSUFWQmdBSkpEUUFhUVI4Z0JVSC8vLzhIU3cwQUdpQUZRU1lnQUVFSWRtY2lBR3QyUVFGeElBQkJBWFJyUVQ1cUN5SUhRUUowUWZ3Y2FpZ0NBQ0lCUlFSQVFRQWhBQXdCQzBFQUlRQWdCVUVaSUFkQkFYWnJRUUFnQjBFZlJ4dDBJUUlEUUFKQUlBRW9BZ1JCZUhFZ0JXc2lCaUFFVHcwQUlBRWhBeUFHSWdRTkFFRUFJUVFnQVNFQURBTUxJQUFnQVNnQ0ZDSUdJQVlnQVNBQ1FSMTJRUVJ4YWlnQ0VDSUJSaHNnQUNBR0d5RUFJQUpCQVhRaEFpQUJEUUFMQ3lBQUlBTnlSUVJBUVFBaEEwRUNJQWQwSWdCQkFDQUFhM0lnQ0hFaUFFVU5BeUFBYUVFQ2RFSDhIR29vQWdBaEFBc2dBRVVOQVFzRFFDQUFLQUlFUVhoeElBVnJJZ0lnQkVraEFTQUNJQVFnQVJzaEJDQUFJQU1nQVJzaEF5QUFLQUlRSWdFRWZ5QUJCU0FBS0FJVUN5SUFEUUFMQ3lBRFJRMEFJQVJCMUJvb0FnQWdCV3RQRFFBZ0F5Z0NHQ0VISUFNZ0F5Z0NEQ0lDUndSQVFkd2FLQUlBR2lBREtBSUlJZ0FnQWpZQ0RDQUNJQUEyQWdnTUJ3c2dBMEVVYWlJQktBSUFJZ0JGQkVBZ0F5Z0NFQ0lBUlEwRElBTkJFR29oQVFzRFFDQUJJUVlnQUNJQ1FSUnFJZ0VvQWdBaUFBMEFJQUpCRUdvaEFTQUNLQUlRSWdBTkFBc2dCa0VBTmdJQURBWUxJQVZCMUJvb0FnQWlBMDBFUUVIZ0dpZ0NBQ0VBQWtBZ0F5QUZheUlCUVJCUEJFQWdBQ0FGYWlJQ0lBRkJBWEkyQWdRZ0FDQURhaUFCTmdJQUlBQWdCVUVEY2pZQ0JBd0JDeUFBSUFOQkEzSTJBZ1FnQUNBRGFpSUJJQUVvQWdSQkFYSTJBZ1JCQUNFQ1FRQWhBUXRCMUJvZ0FUWUNBRUhnR2lBQ05nSUFJQUJCQ0dvaEFBd0lDeUFGUWRnYUtBSUFJZ0pKQkVCQjJCb2dBaUFGYXlJQk5nSUFRZVFhUWVRYUtBSUFJZ0FnQldvaUFqWUNBQ0FDSUFGQkFYSTJBZ1FnQUNBRlFRTnlOZ0lFSUFCQkNHb2hBQXdJQzBFQUlRQWdCVUV2YWlJRUFuOUJwQjRvQWdBRVFFR3NIaWdDQUF3QkMwR3dIa0ovTndJQVFhZ2VRb0NnZ0lDQWdBUTNBZ0JCcEI0Z0NrRU1ha0Z3Y1VIWXF0V3FCWE0yQWdCQnVCNUJBRFlDQUVHSUhrRUFOZ0lBUVlBZ0N5SUJhaUlHUVFBZ0FXc2lDSEVpQVNBRlRRMEhRWVFlS0FJQUlnTUVRRUg4SFNnQ0FDSUhJQUZxSWdrZ0IwMGdBeUFKU1hJTkNBc0NRRUdJSGkwQUFFRUVjVVVFUUFKQUFrQUNRQUpBUWVRYUtBSUFJZ01FUUVHTUhpRUFBMEFnQXlBQUtBSUFJZ2RQQkVBZ0J5QUFLQUlFYWlBRFN3MERDeUFBS0FJSUlnQU5BQXNMUVFBUUN5SUNRWDlHRFFNZ0FTRUdRYWdlS0FJQUlnQkJBV3NpQXlBQ2NRUkFJQUVnQW1zZ0FpQURha0VBSUFCcmNXb2hCZ3NnQlNBR1R3MERRWVFlS0FJQUlnQUVRRUg4SFNnQ0FDSURJQVpxSWdnZ0EwMGdBQ0FJU1hJTkJBc2dCaEFMSWdBZ0FrY05BUXdGQ3lBR0lBSnJJQWh4SWdZUUN5SUNJQUFvQWdBZ0FDZ0NCR3BHRFFFZ0FpRUFDeUFBUVg5R0RRRWdCVUV3YWlBR1RRUkFJQUFoQWd3RUMwR3NIaWdDQUNJQ0lBUWdCbXRxUVFBZ0FtdHhJZ0lRQzBGL1JnMEJJQUlnQm1vaEJpQUFJUUlNQXdzZ0FrRi9SdzBDQzBHSUhrR0lIaWdDQUVFRWNqWUNBQXNnQVJBTElnSkJmMFpCQUJBTElnQkJmMFp5SUFBZ0FrMXlEUVVnQUNBQ2F5SUdJQVZCS0dwTkRRVUxRZndkUWZ3ZEtBSUFJQVpxSWdBMkFnQkJnQjRvQWdBZ0FFa0VRRUdBSGlBQU5nSUFDd0pBUWVRYUtBSUFJZ1FFUUVHTUhpRUFBMEFnQWlBQUtBSUFJZ0VnQUNnQ0JDSURha1lOQWlBQUtBSUlJZ0FOQUFzTUJBdEIzQm9vQWdBaUFFRUFJQUFnQWswYlJRUkFRZHdhSUFJMkFnQUxRUUFoQUVHUUhpQUdOZ0lBUVl3ZUlBSTJBZ0JCN0JwQmZ6WUNBRUh3R2tHa0hpZ0NBRFlDQUVHWUhrRUFOZ0lBQTBBZ0FFRURkQ0lCUWZ3YWFpQUJRZlFhYWlJRE5nSUFJQUZCZ0J0cUlBTTJBZ0FnQUVFQmFpSUFRU0JIRFFBTFFkZ2FJQVpCS0dzaUFFRjRJQUpyUVFkeElnRnJJZ00yQWdCQjVCb2dBU0FDYWlJQk5nSUFJQUVnQTBFQmNqWUNCQ0FBSUFKcVFTZzJBZ1JCNkJwQnRCNG9BZ0EyQWdBTUJBc2dBaUFFVFNBQklBUkxjZzBDSUFBb0FneEJDSEVOQWlBQUlBTWdCbW8yQWdSQjVCb2dCRUY0SUFSclFRZHhJZ0JxSWdFMkFnQkIyQnBCMkJvb0FnQWdCbW9pQWlBQWF5SUFOZ0lBSUFFZ0FFRUJjallDQkNBQ0lBUnFRU2cyQWdSQjZCcEJ0QjRvQWdBMkFnQU1Bd3RCQUNFRERBVUxRUUFoQWd3REMwSGNHaWdDQUNBQ1N3UkFRZHdhSUFJMkFnQUxJQUlnQm1vaEFVR01IaUVBQWtBQ1FBSkFBMEFnQVNBQUtBSUFSd1JBSUFBb0FnZ2lBQTBCREFJTEN5QUFMUUFNUVFoeFJRMEJDMEdNSGlFQUEwQUNRQ0FFSUFBb0FnQWlBVThFUUNBQklBQW9BZ1JxSWdNZ0JFc05BUXNnQUNnQ0NDRUFEQUVMQzBIWUdpQUdRU2hySWdCQmVDQUNhMEVIY1NJQmF5SUlOZ0lBUWVRYUlBRWdBbW9pQVRZQ0FDQUJJQWhCQVhJMkFnUWdBQ0FDYWtFb05nSUVRZWdhUWJRZUtBSUFOZ0lBSUFRZ0EwRW5JQU5yUVFkeGFrRXZheUlBSUFBZ0JFRVFha2tiSWdGQkd6WUNCQ0FCUVpRZUtRSUFOd0lRSUFGQmpCNHBBZ0EzQWdoQmxCNGdBVUVJYWpZQ0FFR1FIaUFHTmdJQVFZd2VJQUkyQWdCQm1CNUJBRFlDQUNBQlFSaHFJUUFEUUNBQVFRYzJBZ1FnQUVFSWFpRU1JQUJCQkdvaEFDQU1JQU5KRFFBTElBRWdCRVlOQWlBQklBRW9BZ1JCZm5FMkFnUWdCQ0FCSUFScklnSkJBWEkyQWdRZ0FTQUNOZ0lBSUFKQi93Rk5CRUFnQWtGNGNVSDBHbW9oQUFKL1Fjd2FLQUlBSWdGQkFTQUNRUU4yZENJQ2NVVUVRRUhNR2lBQklBSnlOZ0lBSUFBTUFRc2dBQ2dDQ0FzaEFTQUFJQVEyQWdnZ0FTQUVOZ0lNSUFRZ0FEWUNEQ0FFSUFFMkFnZ01Bd3RCSHlFQUlBSkIvLy8vQjAwRVFDQUNRU1lnQWtFSWRtY2lBR3QyUVFGeElBQkJBWFJyUVQ1cUlRQUxJQVFnQURZQ0hDQUVRZ0EzQWhBZ0FFRUNkRUg4SEdvaEFRSkFRZEFhS0FJQUlnTkJBU0FBZENJR2NVVUVRRUhRR2lBRElBWnlOZ0lBSUFFZ0JEWUNBQXdCQ3lBQ1FSa2dBRUVCZG10QkFDQUFRUjlIRzNRaEFDQUJLQUlBSVFNRFFDQURJZ0VvQWdSQmVIRWdBa1lOQXlBQVFSMTJJUU1nQUVFQmRDRUFJQUVnQTBFRWNXb2lCaWdDRUNJRERRQUxJQVlnQkRZQ0VBc2dCQ0FCTmdJWUlBUWdCRFlDRENBRUlBUTJBZ2dNQWdzZ0FDQUNOZ0lBSUFBZ0FDZ0NCQ0FHYWpZQ0JDQUNRWGdnQW10QkIzRnFJZ2NnQlVFRGNqWUNCQ0FCUVhnZ0FXdEJCM0ZxSWdRZ0JTQUhhaUlGYXlFR0FrQkI1Qm9vQWdBZ0JFWUVRRUhrR2lBRk5nSUFRZGdhUWRnYUtBSUFJQVpxSWdBMkFnQWdCU0FBUVFGeU5nSUVEQUVMUWVBYUtBSUFJQVJHQkVCQjRCb2dCVFlDQUVIVUdrSFVHaWdDQUNBR2FpSUFOZ0lBSUFVZ0FFRUJjallDQkNBQUlBVnFJQUEyQWdBTUFRc2dCQ2dDQkNJQ1FRTnhRUUZHQkVBZ0FrRjRjU0VKQWtBZ0FrSC9BVTBFUUNBRUtBSU1JZ0FnQkNnQ0NDSUJSZ1JBUWN3YVFjd2FLQUlBUVg0Z0FrRURkbmR4TmdJQURBSUxJQUVnQURZQ0RDQUFJQUUyQWdnTUFRc2dCQ2dDR0NFSUFrQWdCQ0FFS0FJTUlnQkhCRUJCM0Jvb0FnQWFJQVFvQWdnaUFTQUFOZ0lNSUFBZ0FUWUNDQXdCQ3dKQUlBUkJGR29pQVNnQ0FDSUNSUVJBSUFRb0FoQWlBa1VOQVNBRVFSQnFJUUVMQTBBZ0FTRURJQUlpQUVFVWFpSUJLQUlBSWdJTkFDQUFRUkJxSVFFZ0FDZ0NFQ0lDRFFBTElBTkJBRFlDQUF3QkMwRUFJUUFMSUFoRkRRQUNRQ0FFS0FJY0lnRkJBblJCL0J4cUlnSW9BZ0FnQkVZRVFDQUNJQUEyQWdBZ0FBMEJRZEFhUWRBYUtBSUFRWDRnQVhkeE5nSUFEQUlMSUFoQkVFRVVJQWdvQWhBZ0JFWWJhaUFBTmdJQUlBQkZEUUVMSUFBZ0NEWUNHQ0FFS0FJUUlnRUVRQ0FBSUFFMkFoQWdBU0FBTmdJWUN5QUVLQUlVSWdGRkRRQWdBQ0FCTmdJVUlBRWdBRFlDR0FzZ0JpQUphaUVHSUFRZ0NXb2lCQ2dDQkNFQ0N5QUVJQUpCZm5FMkFnUWdCU0FHUVFGeU5nSUVJQVVnQm1vZ0JqWUNBQ0FHUWY4QlRRUkFJQVpCZUhGQjlCcHFJUUFDZjBITUdpZ0NBQ0lCUVFFZ0JrRURkblFpQW5GRkJFQkJ6Qm9nQVNBQ2NqWUNBQ0FBREFFTElBQW9BZ2dMSVFFZ0FDQUZOZ0lJSUFFZ0JUWUNEQ0FGSUFBMkFnd2dCU0FCTmdJSURBRUxRUjhoQWlBR1FmLy8vd2ROQkVBZ0JrRW1JQVpCQ0habklnQnJka0VCY1NBQVFRRjBhMEUrYWlFQ0N5QUZJQUkyQWh3Z0JVSUFOd0lRSUFKQkFuUkIvQnhxSVFFQ1FBSkFRZEFhS0FJQUlnQkJBU0FDZENJRGNVVUVRRUhRR2lBQUlBTnlOZ0lBSUFFZ0JUWUNBQXdCQ3lBR1FSa2dBa0VCZG10QkFDQUNRUjlIRzNRaEFpQUJLQUlBSVFBRFFDQUFJZ0VvQWdSQmVIRWdCa1lOQWlBQ1FSMTJJUUFnQWtFQmRDRUNJQUVnQUVFRWNXb2lBeWdDRUNJQURRQUxJQU1nQlRZQ0VBc2dCU0FCTmdJWUlBVWdCVFlDRENBRklBVTJBZ2dNQVFzZ0FTZ0NDQ0lBSUFVMkFnd2dBU0FGTmdJSUlBVkJBRFlDR0NBRklBRTJBZ3dnQlNBQU5nSUlDeUFIUVFocUlRQU1CUXNnQVNnQ0NDSUFJQVEyQWd3Z0FTQUVOZ0lJSUFSQkFEWUNHQ0FFSUFFMkFnd2dCQ0FBTmdJSUMwSFlHaWdDQUNJQUlBVk5EUUJCMkJvZ0FDQUZheUlCTmdJQVFlUWFRZVFhS0FJQUlnQWdCV29pQWpZQ0FDQUNJQUZCQVhJMkFnUWdBQ0FGUVFOeU5nSUVJQUJCQ0dvaEFBd0RDMEhJR2tFd05nSUFRUUFoQUF3Q0N3SkFJQWRGRFFBQ1FDQURLQUljSWdCQkFuUkIvQnhxSWdFb0FnQWdBMFlFUUNBQklBSTJBZ0FnQWcwQlFkQWFJQWhCZmlBQWQzRWlDRFlDQUF3Q0N5QUhRUkJCRkNBSEtBSVFJQU5HRzJvZ0FqWUNBQ0FDUlEwQkN5QUNJQWMyQWhnZ0F5Z0NFQ0lBQkVBZ0FpQUFOZ0lRSUFBZ0FqWUNHQXNnQXlnQ0ZDSUFSUTBBSUFJZ0FEWUNGQ0FBSUFJMkFoZ0xBa0FnQkVFUFRRUkFJQU1nQkNBRmFpSUFRUU55TmdJRUlBQWdBMm9pQUNBQUtBSUVRUUZ5TmdJRURBRUxJQU1nQlVFRGNqWUNCQ0FESUFWcUlnSWdCRUVCY2pZQ0JDQUNJQVJxSUFRMkFnQWdCRUgvQVUwRVFDQUVRWGh4UWZRYWFpRUFBbjlCekJvb0FnQWlBVUVCSUFSQkEzWjBJZ1Z4UlFSQVFjd2FJQUVnQlhJMkFnQWdBQXdCQ3lBQUtBSUlDeUVCSUFBZ0FqWUNDQ0FCSUFJMkFnd2dBaUFBTmdJTUlBSWdBVFlDQ0F3QkMwRWZJUUFnQkVILy8vOEhUUVJBSUFSQkppQUVRUWgyWnlJQWEzWkJBWEVnQUVFQmRHdEJQbW9oQUFzZ0FpQUFOZ0ljSUFKQ0FEY0NFQ0FBUVFKMFFmd2NhaUVCQWtBQ1FDQUlRUUVnQUhRaUJYRkZCRUJCMEJvZ0JTQUljallDQUNBQklBSTJBZ0FNQVFzZ0JFRVpJQUJCQVhaclFRQWdBRUVmUnh0MElRQWdBU2dDQUNFRkEwQWdCU0lCS0FJRVFYaHhJQVJHRFFJZ0FFRWRkaUVGSUFCQkFYUWhBQ0FCSUFWQkJIRnFJZ1lvQWhBaUJRMEFDeUFHSUFJMkFoQUxJQUlnQVRZQ0dDQUNJQUkyQWd3Z0FpQUNOZ0lJREFFTElBRW9BZ2dpQUNBQ05nSU1JQUVnQWpZQ0NDQUNRUUEyQWhnZ0FpQUJOZ0lNSUFJZ0FEWUNDQXNnQTBFSWFpRUFEQUVMQWtBZ0NVVU5BQUpBSUFJb0Fod2lBRUVDZEVIOEhHb2lBU2dDQUNBQ1JnUkFJQUVnQXpZQ0FDQUREUUZCMEJvZ0MwRitJQUIzY1RZQ0FBd0NDeUFKUVJCQkZDQUpLQUlRSUFKR0cyb2dBellDQUNBRFJRMEJDeUFESUFrMkFoZ2dBaWdDRUNJQUJFQWdBeUFBTmdJUUlBQWdBellDR0FzZ0FpZ0NGQ0lBUlEwQUlBTWdBRFlDRkNBQUlBTTJBaGdMQWtBZ0JFRVBUUVJBSUFJZ0JDQUZhaUlBUVFOeU5nSUVJQUFnQW1vaUFDQUFLQUlFUVFGeU5nSUVEQUVMSUFJZ0JVRURjallDQkNBQ0lBVnFJZ01nQkVFQmNqWUNCQ0FESUFScUlBUTJBZ0FnQndSQUlBZEJlSEZCOUJwcUlRQkI0Qm9vQWdBaEFRSi9RUUVnQjBFRGRuUWlCU0FHY1VVRVFFSE1HaUFGSUFaeU5nSUFJQUFNQVFzZ0FDZ0NDQXNoQlNBQUlBRTJBZ2dnQlNBQk5nSU1JQUVnQURZQ0RDQUJJQVUyQWdnTFFlQWFJQU0yQWdCQjFCb2dCRFlDQUFzZ0FrRUlhaUVBQ3lBS1FSQnFKQUFnQUFzYUFDQUFJQUVvQWdnZ0JSQUtCRUFnQVNBQ0lBTWdCQkFVQ3dzM0FDQUFJQUVvQWdnZ0JSQUtCRUFnQVNBQ0lBTWdCQkFVRHdzZ0FDZ0NDQ0lBSUFFZ0FpQURJQVFnQlNBQUtBSUFLQUlVRVFNQUM1RUJBQ0FBSUFFb0FnZ2dCQkFLQkVBZ0FTQUNJQU1RRXc4TEFrQWdBQ0FCS0FJQUlBUVFDa1VOQUFKQUlBSWdBU2dDRUVjRVFDQUJLQUlVSUFKSERRRUxJQU5CQVVjTkFTQUJRUUUyQWlBUEN5QUJJQUkyQWhRZ0FTQUROZ0lnSUFFZ0FTZ0NLRUVCYWpZQ0tBSkFJQUVvQWlSQkFVY05BQ0FCS0FJWVFRSkhEUUFnQVVFQk9nQTJDeUFCUVFRMkFpd0xDL0lCQUNBQUlBRW9BZ2dnQkJBS0JFQWdBU0FDSUFNUUV3OExBa0FnQUNBQktBSUFJQVFRQ2dSQUFrQWdBaUFCS0FJUVJ3UkFJQUVvQWhRZ0FrY05BUXNnQTBFQlJ3MENJQUZCQVRZQ0lBOExJQUVnQXpZQ0lBSkFJQUVvQWl4QkJFWU5BQ0FCUVFBN0FUUWdBQ2dDQ0NJQUlBRWdBaUFDUVFFZ0JDQUFLQUlBS0FJVUVRTUFJQUV0QURVRVFDQUJRUU0yQWl3Z0FTMEFORVVOQVF3REN5QUJRUVEyQWl3TElBRWdBallDRkNBQklBRW9BaWhCQVdvMkFpZ2dBU2dDSkVFQlJ3MEJJQUVvQWhoQkFrY05BU0FCUVFFNkFEWVBDeUFBS0FJSUlnQWdBU0FDSUFNZ0JDQUFLQUlBS0FJWUVRSUFDd3N4QUNBQUlBRW9BZ2hCQUJBS0JFQWdBU0FDSUFNUUZROExJQUFvQWdnaUFDQUJJQUlnQXlBQUtBSUFLQUljRVFBQUN4Z0FJQUFnQVNnQ0NFRUFFQW9FUUNBQklBSWdBeEFWQ3d1QUF3RUVmeU1BUWZBQWF5SUNKQUFnQUNnQ0FDSURRUVJyS0FJQUlRUWdBMEVJYXlnQ0FDRUZJQUpDQURjQ1VDQUNRZ0EzQWxnZ0FrSUFOd0pnSUFKQ0FEY0FaeUFDUWdBM0FrZ2dBa0VBTmdKRUlBSkIvQlUyQWtBZ0FpQUFOZ0k4SUFJZ0FUWUNPQ0FBSUFWcUlRTUNRQ0FFSUFGQkFCQUtCRUJCQUNBRElBVWJJUUFNQVFzZ0FDQURUZ1JBSUFKQ0FEY0FMeUFDUWdBM0FoZ2dBa0lBTndJZ0lBSkNBRGNDS0NBQ1FnQTNBaEFnQWtFQU5nSU1JQUlnQVRZQ0NDQUNJQUEyQWdRZ0FpQUVOZ0lBSUFKQkFUWUNNQ0FFSUFJZ0F5QURRUUZCQUNBRUtBSUFLQUlVRVFNQUlBSW9BaGdOQVF0QkFDRUFJQVFnQWtFNGFpQURRUUZCQUNBRUtBSUFLQUlZRVFJQUFrQUNRQ0FDS0FKY0RnSUFBUUlMSUFJb0FreEJBQ0FDS0FKWVFRRkdHMEVBSUFJb0FsUkJBVVliUVFBZ0FpZ0NZRUVCUmhzaEFBd0JDeUFDS0FKUVFRRkhCRUFnQWlnQ1lBMEJJQUlvQWxSQkFVY05BU0FDS0FKWVFRRkhEUUVMSUFJb0FrZ2hBQXNnQWtId0FHb2tBQ0FBQzVvQkFRSi9Jd0JCUUdvaUF5UUFBbjlCQVNBQUlBRkJBQkFLRFFBYVFRQWdBVVVOQUJwQkFDQUJRYXdXRUI0aUFVVU5BQm9nQTBFTWFrRTBFQkFhSUFOQkFUWUNPQ0FEUVg4MkFoUWdBeUFBTmdJUUlBTWdBVFlDQ0NBQklBTkJDR29nQWlnQ0FFRUJJQUVvQWdBb0Fod1JBQUFnQXlnQ0lDSUFRUUZHQkVBZ0FpQURLQUlZTmdJQUN5QUFRUUZHQ3lFRUlBTkJRR3NrQUNBRUN3b0FJQUFnQVVFQUVBb0xxUU1DQkg4Q2ZVSC8vLy8vQnlFSlFZQ0FnSUI0SVFvRFFDQUJJQWhHQkVCQkFDRUhJQVpCZ0lBUUVCQWhBRU1BQUlCSElBb2dDV3V5bFNFTUEwQWdBU0FIUmdSQVFRQWhCeUFGUVFBMkFnQWdBRUVFYXlFQVFRQWhDVUVCSVFnRFFDQUlRWUNBQkVaRkJFQWdCU0FJUVFKMElnSnFJQUFnQW1vb0FnQWdDV29pQ1RZQ0FDQUlRUUZxSVFnTUFRc0xBMEFnQVNBSFJrVUVRQ0FGSUFNZ0IwRUNkR29vQWdCQkFuUnFJZ0FnQUNnQ0FDSUFRUUZxTmdJQUlBUWdBRUVDZEdvZ0J6WUNBQ0FIUVFGcUlRY01BUXNMQlFKL0lBd2dBeUFIUVFKMGFpSUNLQUlBSUFscnM1UWlDME1BQUlCUFhTQUxRd0FBQUFCZ2NRUkFJQXVwREFFTFFRQUxJUWdnQWlBSU5nSUFJQUFnQ0VFQ2RHb2lBaUFDS0FJQVFRRnFOZ0lBSUFkQkFXb2hCd3dCQ3dzRklBTWdDRUVDZEdvQ2Z5QUFLZ0lJSUFJZ0NFRU1iR29pQnlvQ0FKUWdBQ29DR0NBSEtnSUVsSklnQUNvQ0tDQUhLZ0lJbEpKREFBQ0FSWlFpQzR0REFBQUFUMTBFUUNBTHFBd0JDMEdBZ0lDQWVBc2lCellDQUNBSklBY2dCeUFKU2hzaENTQUtJQWNnQnlBS1NCc2hDaUFJUVFGcUlRZ01BUXNMQ3d2SEVnSUFRWUFJQzdZU2RXNXphV2R1WldRZ2MyaHZjblFBZFc1emFXZHVaV1FnYVc1MEFHWnNiMkYwQUhWcGJuUTJORjkwQUhWdWMybG5ibVZrSUdOb1lYSUFZbTl2YkFCbGJYTmpjbWx3ZEdWdU9qcDJZV3dBZFc1emFXZHVaV1FnYkc5dVp3QnpkR1E2T25kemRISnBibWNBYzNSa09qcHpkSEpwYm1jQWMzUmtPanAxTVRaemRISnBibWNBYzNSa09qcDFNekp6ZEhKcGJtY0FaRzkxWW14bEFIWnZhV1FBWlcxelkzSnBjSFJsYmpvNmJXVnRiM0o1WDNacFpYYzhjMmh2Y25RK0FHVnRjMk55YVhCMFpXNDZPbTFsYlc5eWVWOTJhV1YzUEhWdWMybG5ibVZrSUhOb2IzSjBQZ0JsYlhOamNtbHdkR1Z1T2pwdFpXMXZjbmxmZG1sbGR6eHBiblErQUdWdGMyTnlhWEIwWlc0Nk9tMWxiVzl5ZVY5MmFXVjNQSFZ1YzJsbmJtVmtJR2x1ZEQ0QVpXMXpZM0pwY0hSbGJqbzZiV1Z0YjNKNVgzWnBaWGM4Wm14dllYUStBR1Z0YzJOeWFYQjBaVzQ2T20xbGJXOXllVjkyYVdWM1BIVnBiblE0WDNRK0FHVnRjMk55YVhCMFpXNDZPbTFsYlc5eWVWOTJhV1YzUEdsdWREaGZkRDRBWlcxelkzSnBjSFJsYmpvNmJXVnRiM0o1WDNacFpYYzhkV2x1ZERFMlgzUStBR1Z0YzJOeWFYQjBaVzQ2T20xbGJXOXllVjkyYVdWM1BHbHVkREUyWDNRK0FHVnRjMk55YVhCMFpXNDZPbTFsYlc5eWVWOTJhV1YzUEhWcGJuUTJORjkwUGdCbGJYTmpjbWx3ZEdWdU9qcHRaVzF2Y25sZmRtbGxkenhwYm5RMk5GOTBQZ0JsYlhOamNtbHdkR1Z1T2pwdFpXMXZjbmxmZG1sbGR6eDFhVzUwTXpKZmRENEFaVzF6WTNKcGNIUmxiam82YldWdGIzSjVYM1pwWlhjOGFXNTBNekpmZEQ0QVpXMXpZM0pwY0hSbGJqbzZiV1Z0YjNKNVgzWnBaWGM4WTJoaGNqNEFaVzF6WTNKcGNIUmxiam82YldWdGIzSjVYM1pwWlhjOGRXNXphV2R1WldRZ1kyaGhjajRBYzNSa09qcGlZWE5wWTE5emRISnBibWM4ZFc1emFXZHVaV1FnWTJoaGNqNEFaVzF6WTNKcGNIUmxiam82YldWdGIzSjVYM1pwWlhjOGMybG5ibVZrSUdOb1lYSStBR1Z0YzJOeWFYQjBaVzQ2T20xbGJXOXllVjkyYVdWM1BHeHZibWMrQUdWdGMyTnlhWEIwWlc0Nk9tMWxiVzl5ZVY5MmFXVjNQSFZ1YzJsbmJtVmtJR3h2Ym1jK0FHVnRjMk55YVhCMFpXNDZPbTFsYlc5eWVWOTJhV1YzUEdSdmRXSnNaVDRBVGxOME0xOWZNakV5WW1GemFXTmZjM1J5YVc1blNXTk9VMTh4TVdOb1lYSmZkSEpoYVhSelNXTkZSVTVUWHpsaGJHeHZZMkYwYjNKSlkwVkZSVVVBQUFBQXBBd0FBRUlIQUFCT1UzUXpYMTh5TVRKaVlYTnBZMTl6ZEhKcGJtZEphRTVUWHpFeFkyaGhjbDkwY21GcGRITkphRVZGVGxOZk9XRnNiRzlqWVhSdmNrbG9SVVZGUlFBQXBBd0FBSXdIQUFCT1UzUXpYMTh5TVRKaVlYTnBZMTl6ZEhKcGJtZEpkMDVUWHpFeFkyaGhjbDkwY21GcGRITkpkMFZGVGxOZk9XRnNiRzlqWVhSdmNrbDNSVVZGUlFBQXBBd0FBTlFIQUFCT1UzUXpYMTh5TVRKaVlYTnBZMTl6ZEhKcGJtZEpSSE5PVTE4eE1XTm9ZWEpmZEhKaGFYUnpTVVJ6UlVWT1UxODVZV3hzYjJOaGRHOXlTVVJ6UlVWRlJRQUFBS1FNQUFBY0NBQUFUbE4wTTE5Zk1qRXlZbUZ6YVdOZmMzUnlhVzVuU1VScFRsTmZNVEZqYUdGeVgzUnlZV2wwYzBsRWFVVkZUbE5mT1dGc2JHOWpZWFJ2Y2tsRWFVVkZSVVVBQUFDa0RBQUFhQWdBQUU0eE1HVnRjMk55YVhCMFpXNHpkbUZzUlFBQXBBd0FBTFFJQUFCT01UQmxiWE5qY21sd2RHVnVNVEZ0WlcxdmNubGZkbWxsZDBsalJVVUFBS1FNQUFEUUNBQUFUakV3WlcxelkzSnBjSFJsYmpFeGJXVnRiM0o1WDNacFpYZEpZVVZGQUFDa0RBQUErQWdBQUU0eE1HVnRjMk55YVhCMFpXNHhNVzFsYlc5eWVWOTJhV1YzU1doRlJRQUFwQXdBQUNBSkFBQk9NVEJsYlhOamNtbHdkR1Z1TVRGdFpXMXZjbmxmZG1sbGQwbHpSVVVBQUtRTUFBQklDUUFBVGpFd1pXMXpZM0pwY0hSbGJqRXhiV1Z0YjNKNVgzWnBaWGRKZEVWRkFBQ2tEQUFBY0FrQUFFNHhNR1Z0YzJOeWFYQjBaVzR4TVcxbGJXOXllVjkyYVdWM1NXbEZSUUFBcEF3QUFKZ0pBQUJPTVRCbGJYTmpjbWx3ZEdWdU1URnRaVzF2Y25sZmRtbGxkMGxxUlVVQUFLUU1BQURBQ1FBQVRqRXdaVzF6WTNKcGNIUmxiakV4YldWdGIzSjVYM1pwWlhkSmJFVkZBQUNrREFBQTZBa0FBRTR4TUdWdGMyTnlhWEIwWlc0eE1XMWxiVzl5ZVY5MmFXVjNTVzFGUlFBQXBBd0FBQkFLQUFCT01UQmxiWE5qY21sd2RHVnVNVEZ0WlcxdmNubGZkbWxsZDBsNFJVVUFBS1FNQUFBNENnQUFUakV3WlcxelkzSnBjSFJsYmpFeGJXVnRiM0o1WDNacFpYZEplVVZGQUFDa0RBQUFZQW9BQUU0eE1HVnRjMk55YVhCMFpXNHhNVzFsYlc5eWVWOTJhV1YzU1daRlJRQUFwQXdBQUlnS0FBQk9NVEJsYlhOamNtbHdkR1Z1TVRGdFpXMXZjbmxmZG1sbGQwbGtSVVVBQUtRTUFBQ3dDZ0FBVGpFd1gxOWplSGhoWW1sMk1URTJYMTl6YUdsdFgzUjVjR1ZmYVc1bWIwVUFBQUFBekF3QUFOZ0tBQUF3RFFBQVRqRXdYMTlqZUhoaFltbDJNVEUzWDE5amJHRnpjMTkwZVhCbFgybHVabTlGQUFBQXpBd0FBQWdMQUFEOENnQUFUakV3WDE5amVIaGhZbWwyTVRFM1gxOXdZbUZ6WlY5MGVYQmxYMmx1Wm05RkFBQUF6QXdBQURnTEFBRDhDZ0FBVGpFd1gxOWplSGhoWW1sMk1URTVYMTl3YjJsdWRHVnlYM1I1Y0dWZmFXNW1iMFVBekF3QUFHZ0xBQUJjQ3dBQUFBQUFBTndMQUFBQ0FBQUFBd0FBQUFRQUFBQUZBQUFBQmdBQUFFNHhNRjlmWTNoNFlXSnBkakV5TTE5ZlpuVnVaR0Z0Wlc1MFlXeGZkSGx3WlY5cGJtWnZSUURNREFBQXRBc0FBUHdLQUFCMkFBQUFvQXNBQU9nTEFBQmlBQUFBb0FzQUFQUUxBQUJqQUFBQW9Bc0FBQUFNQUFCb0FBQUFvQXNBQUF3TUFBQmhBQUFBb0FzQUFCZ01BQUJ6QUFBQW9Bc0FBQ1FNQUFCMEFBQUFvQXNBQURBTUFBQnBBQUFBb0FzQUFEd01BQUJxQUFBQW9Bc0FBRWdNQUFCc0FBQUFvQXNBQUZRTUFBQnRBQUFBb0FzQUFHQU1BQUI0QUFBQW9Bc0FBR3dNQUFCNUFBQUFvQXNBQUhnTUFBQm1BQUFBb0FzQUFJUU1BQUJrQUFBQW9Bc0FBSkFNQUFBQUFBQUFMQXNBQUFJQUFBQUhBQUFBQkFBQUFBVUFBQUFJQUFBQUNRQUFBQW9BQUFBTEFBQUFBQUFBQUJRTkFBQUNBQUFBREFBQUFBUUFBQUFGQUFBQUNBQUFBQTBBQUFBT0FBQUFEd0FBQUU0eE1GOWZZM2g0WVdKcGRqRXlNRjlmYzJsZlkyeGhjM05mZEhsd1pWOXBibVp2UlFBQUFBRE1EQUFBN0F3QUFDd0xBQUJUZERsMGVYQmxYMmx1Wm04QUFBQUFwQXdBQUNBTkFFRzRHZ3NEUUE4QiI7aWYoIWlzRGF0YVVSSSh3YXNtQmluYXJ5RmlsZSkpe3dhc21CaW5hcnlGaWxlPWxvY2F0ZUZpbGUod2FzbUJpbmFyeUZpbGUpO31mdW5jdGlvbiBnZXRCaW5hcnlTeW5jKGZpbGUpe2lmKGZpbGU9PXdhc21CaW5hcnlGaWxlJiZ3YXNtQmluYXJ5KXtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkod2FzbUJpbmFyeSl9dmFyIGJpbmFyeT10cnlQYXJzZUFzRGF0YVVSSShmaWxlKTtpZihiaW5hcnkpe3JldHVybiBiaW5hcnl9aWYocmVhZEJpbmFyeSl7cmV0dXJuIHJlYWRCaW5hcnkoZmlsZSl9dGhyb3cgImJvdGggYXN5bmMgYW5kIHN5bmMgZmV0Y2hpbmcgb2YgdGhlIHdhc20gZmFpbGVkIn1mdW5jdGlvbiBnZXRCaW5hcnlQcm9taXNlKGJpbmFyeUZpbGUpe3JldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpPT5nZXRCaW5hcnlTeW5jKGJpbmFyeUZpbGUpKX1mdW5jdGlvbiBpbnN0YW50aWF0ZUFycmF5QnVmZmVyKGJpbmFyeUZpbGUsaW1wb3J0cyxyZWNlaXZlcil7cmV0dXJuIGdldEJpbmFyeVByb21pc2UoYmluYXJ5RmlsZSkudGhlbihiaW5hcnk9PldlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGJpbmFyeSxpbXBvcnRzKSkudGhlbihpbnN0YW5jZT0+aW5zdGFuY2UpLnRoZW4ocmVjZWl2ZXIscmVhc29uPT57ZXJyKGBmYWlsZWQgdG8gYXN5bmNocm9ub3VzbHkgcHJlcGFyZSB3YXNtOiAke3JlYXNvbn1gKTthYm9ydChyZWFzb24pO30pfWZ1bmN0aW9uIGluc3RhbnRpYXRlQXN5bmMoYmluYXJ5LGJpbmFyeUZpbGUsaW1wb3J0cyxjYWxsYmFjayl7cmV0dXJuIGluc3RhbnRpYXRlQXJyYXlCdWZmZXIoYmluYXJ5RmlsZSxpbXBvcnRzLGNhbGxiYWNrKX1mdW5jdGlvbiBjcmVhdGVXYXNtKCl7dmFyIGluZm89eyJhIjp3YXNtSW1wb3J0c307ZnVuY3Rpb24gcmVjZWl2ZUluc3RhbmNlKGluc3RhbmNlLG1vZHVsZSl7d2FzbUV4cG9ydHM9aW5zdGFuY2UuZXhwb3J0czt3YXNtTWVtb3J5PXdhc21FeHBvcnRzWyJrIl07dXBkYXRlTWVtb3J5Vmlld3MoKTthZGRPbkluaXQod2FzbUV4cG9ydHNbImwiXSk7cmVtb3ZlUnVuRGVwZW5kZW5jeSgpO3JldHVybiB3YXNtRXhwb3J0c31hZGRSdW5EZXBlbmRlbmN5KCk7ZnVuY3Rpb24gcmVjZWl2ZUluc3RhbnRpYXRpb25SZXN1bHQocmVzdWx0KXtyZWNlaXZlSW5zdGFuY2UocmVzdWx0WyJpbnN0YW5jZSJdKTt9aWYoTW9kdWxlWyJpbnN0YW50aWF0ZVdhc20iXSl7dHJ5e3JldHVybiBNb2R1bGVbImluc3RhbnRpYXRlV2FzbSJdKGluZm8scmVjZWl2ZUluc3RhbmNlKX1jYXRjaChlKXtlcnIoYE1vZHVsZS5pbnN0YW50aWF0ZVdhc20gY2FsbGJhY2sgZmFpbGVkIHdpdGggZXJyb3I6ICR7ZX1gKTtyZWFkeVByb21pc2VSZWplY3QoZSk7fX1pbnN0YW50aWF0ZUFzeW5jKHdhc21CaW5hcnksd2FzbUJpbmFyeUZpbGUsaW5mbyxyZWNlaXZlSW5zdGFudGlhdGlvblJlc3VsdCkuY2F0Y2gocmVhZHlQcm9taXNlUmVqZWN0KTtyZXR1cm4ge319dmFyIGNhbGxSdW50aW1lQ2FsbGJhY2tzPWNhbGxiYWNrcz0+e3doaWxlKGNhbGxiYWNrcy5sZW5ndGg+MCl7Y2FsbGJhY2tzLnNoaWZ0KCkoTW9kdWxlKTt9fTtNb2R1bGVbIm5vRXhpdFJ1bnRpbWUiXXx8dHJ1ZTt2YXIgX19lbWJpbmRfcmVnaXN0ZXJfYmlnaW50PShwcmltaXRpdmVUeXBlLG5hbWUsc2l6ZSxtaW5SYW5nZSxtYXhSYW5nZSk9Pnt9O3ZhciBlbWJpbmRfaW5pdF9jaGFyQ29kZXM9KCk9Pnt2YXIgY29kZXM9bmV3IEFycmF5KDI1Nik7Zm9yKHZhciBpPTA7aTwyNTY7KytpKXtjb2Rlc1tpXT1TdHJpbmcuZnJvbUNoYXJDb2RlKGkpO31lbWJpbmRfY2hhckNvZGVzPWNvZGVzO307dmFyIGVtYmluZF9jaGFyQ29kZXM7dmFyIHJlYWRMYXRpbjFTdHJpbmc9cHRyPT57dmFyIHJldD0iIjt2YXIgYz1wdHI7d2hpbGUoSEVBUFU4W2NdKXtyZXQrPWVtYmluZF9jaGFyQ29kZXNbSEVBUFU4W2MrK11dO31yZXR1cm4gcmV0fTt2YXIgYXdhaXRpbmdEZXBlbmRlbmNpZXM9e307dmFyIHJlZ2lzdGVyZWRUeXBlcz17fTt2YXIgQmluZGluZ0Vycm9yO3ZhciB0aHJvd0JpbmRpbmdFcnJvcj1tZXNzYWdlPT57dGhyb3cgbmV3IEJpbmRpbmdFcnJvcihtZXNzYWdlKX07ZnVuY3Rpb24gc2hhcmVkUmVnaXN0ZXJUeXBlKHJhd1R5cGUscmVnaXN0ZXJlZEluc3RhbmNlLG9wdGlvbnM9e30pe3ZhciBuYW1lPXJlZ2lzdGVyZWRJbnN0YW5jZS5uYW1lO2lmKCFyYXdUeXBlKXt0aHJvd0JpbmRpbmdFcnJvcihgdHlwZSAiJHtuYW1lfSIgbXVzdCBoYXZlIGEgcG9zaXRpdmUgaW50ZWdlciB0eXBlaWQgcG9pbnRlcmApO31pZihyZWdpc3RlcmVkVHlwZXMuaGFzT3duUHJvcGVydHkocmF3VHlwZSkpe2lmKG9wdGlvbnMuaWdub3JlRHVwbGljYXRlUmVnaXN0cmF0aW9ucyl7cmV0dXJufWVsc2Uge3Rocm93QmluZGluZ0Vycm9yKGBDYW5ub3QgcmVnaXN0ZXIgdHlwZSAnJHtuYW1lfScgdHdpY2VgKTt9fXJlZ2lzdGVyZWRUeXBlc1tyYXdUeXBlXT1yZWdpc3RlcmVkSW5zdGFuY2U7aWYoYXdhaXRpbmdEZXBlbmRlbmNpZXMuaGFzT3duUHJvcGVydHkocmF3VHlwZSkpe3ZhciBjYWxsYmFja3M9YXdhaXRpbmdEZXBlbmRlbmNpZXNbcmF3VHlwZV07ZGVsZXRlIGF3YWl0aW5nRGVwZW5kZW5jaWVzW3Jhd1R5cGVdO2NhbGxiYWNrcy5mb3JFYWNoKGNiPT5jYigpKTt9fWZ1bmN0aW9uIHJlZ2lzdGVyVHlwZShyYXdUeXBlLHJlZ2lzdGVyZWRJbnN0YW5jZSxvcHRpb25zPXt9KXtpZighKCJhcmdQYWNrQWR2YW5jZSJpbiByZWdpc3RlcmVkSW5zdGFuY2UpKXt0aHJvdyBuZXcgVHlwZUVycm9yKCJyZWdpc3RlclR5cGUgcmVnaXN0ZXJlZEluc3RhbmNlIHJlcXVpcmVzIGFyZ1BhY2tBZHZhbmNlIil9cmV0dXJuIHNoYXJlZFJlZ2lzdGVyVHlwZShyYXdUeXBlLHJlZ2lzdGVyZWRJbnN0YW5jZSxvcHRpb25zKX12YXIgR2VuZXJpY1dpcmVUeXBlU2l6ZT04O3ZhciBfX2VtYmluZF9yZWdpc3Rlcl9ib29sPShyYXdUeXBlLG5hbWUsdHJ1ZVZhbHVlLGZhbHNlVmFsdWUpPT57bmFtZT1yZWFkTGF0aW4xU3RyaW5nKG5hbWUpO3JlZ2lzdGVyVHlwZShyYXdUeXBlLHtuYW1lOm5hbWUsImZyb21XaXJlVHlwZSI6ZnVuY3Rpb24od3Qpe3JldHVybiAhIXd0fSwidG9XaXJlVHlwZSI6ZnVuY3Rpb24oZGVzdHJ1Y3RvcnMsbyl7cmV0dXJuIG8/dHJ1ZVZhbHVlOmZhbHNlVmFsdWV9LCJhcmdQYWNrQWR2YW5jZSI6R2VuZXJpY1dpcmVUeXBlU2l6ZSwicmVhZFZhbHVlRnJvbVBvaW50ZXIiOmZ1bmN0aW9uKHBvaW50ZXIpe3JldHVybiB0aGlzWyJmcm9tV2lyZVR5cGUiXShIRUFQVThbcG9pbnRlcl0pfSxkZXN0cnVjdG9yRnVuY3Rpb246bnVsbH0pO307ZnVuY3Rpb24gaGFuZGxlQWxsb2NhdG9ySW5pdCgpe09iamVjdC5hc3NpZ24oSGFuZGxlQWxsb2NhdG9yLnByb3RvdHlwZSx7Z2V0KGlkKXtyZXR1cm4gdGhpcy5hbGxvY2F0ZWRbaWRdfSxoYXMoaWQpe3JldHVybiB0aGlzLmFsbG9jYXRlZFtpZF0hPT11bmRlZmluZWR9LGFsbG9jYXRlKGhhbmRsZSl7dmFyIGlkPXRoaXMuZnJlZWxpc3QucG9wKCl8fHRoaXMuYWxsb2NhdGVkLmxlbmd0aDt0aGlzLmFsbG9jYXRlZFtpZF09aGFuZGxlO3JldHVybiBpZH0sZnJlZShpZCl7dGhpcy5hbGxvY2F0ZWRbaWRdPXVuZGVmaW5lZDt0aGlzLmZyZWVsaXN0LnB1c2goaWQpO319KTt9ZnVuY3Rpb24gSGFuZGxlQWxsb2NhdG9yKCl7dGhpcy5hbGxvY2F0ZWQ9W3VuZGVmaW5lZF07dGhpcy5mcmVlbGlzdD1bXTt9dmFyIGVtdmFsX2hhbmRsZXM9bmV3IEhhbmRsZUFsbG9jYXRvcjt2YXIgX19lbXZhbF9kZWNyZWY9aGFuZGxlPT57aWYoaGFuZGxlPj1lbXZhbF9oYW5kbGVzLnJlc2VydmVkJiYwPT09LS1lbXZhbF9oYW5kbGVzLmdldChoYW5kbGUpLnJlZmNvdW50KXtlbXZhbF9oYW5kbGVzLmZyZWUoaGFuZGxlKTt9fTt2YXIgY291bnRfZW12YWxfaGFuZGxlcz0oKT0+e3ZhciBjb3VudD0wO2Zvcih2YXIgaT1lbXZhbF9oYW5kbGVzLnJlc2VydmVkO2k8ZW12YWxfaGFuZGxlcy5hbGxvY2F0ZWQubGVuZ3RoOysraSl7aWYoZW12YWxfaGFuZGxlcy5hbGxvY2F0ZWRbaV0hPT11bmRlZmluZWQpeysrY291bnQ7fX1yZXR1cm4gY291bnR9O3ZhciBpbml0X2VtdmFsPSgpPT57ZW12YWxfaGFuZGxlcy5hbGxvY2F0ZWQucHVzaCh7dmFsdWU6dW5kZWZpbmVkfSx7dmFsdWU6bnVsbH0se3ZhbHVlOnRydWV9LHt2YWx1ZTpmYWxzZX0pO2VtdmFsX2hhbmRsZXMucmVzZXJ2ZWQ9ZW12YWxfaGFuZGxlcy5hbGxvY2F0ZWQubGVuZ3RoO01vZHVsZVsiY291bnRfZW12YWxfaGFuZGxlcyJdPWNvdW50X2VtdmFsX2hhbmRsZXM7fTt2YXIgRW12YWw9e3RvVmFsdWU6aGFuZGxlPT57aWYoIWhhbmRsZSl7dGhyb3dCaW5kaW5nRXJyb3IoIkNhbm5vdCB1c2UgZGVsZXRlZCB2YWwuIGhhbmRsZSA9ICIraGFuZGxlKTt9cmV0dXJuIGVtdmFsX2hhbmRsZXMuZ2V0KGhhbmRsZSkudmFsdWV9LHRvSGFuZGxlOnZhbHVlPT57c3dpdGNoKHZhbHVlKXtjYXNlIHVuZGVmaW5lZDpyZXR1cm4gMTtjYXNlIG51bGw6cmV0dXJuIDI7Y2FzZSB0cnVlOnJldHVybiAzO2Nhc2UgZmFsc2U6cmV0dXJuIDQ7ZGVmYXVsdDp7cmV0dXJuIGVtdmFsX2hhbmRsZXMuYWxsb2NhdGUoe3JlZmNvdW50OjEsdmFsdWU6dmFsdWV9KX19fX07ZnVuY3Rpb24gc2ltcGxlUmVhZFZhbHVlRnJvbVBvaW50ZXIocG9pbnRlcil7cmV0dXJuIHRoaXNbImZyb21XaXJlVHlwZSJdKEhFQVAzMltwb2ludGVyPj4yXSl9dmFyIF9fZW1iaW5kX3JlZ2lzdGVyX2VtdmFsPShyYXdUeXBlLG5hbWUpPT57bmFtZT1yZWFkTGF0aW4xU3RyaW5nKG5hbWUpO3JlZ2lzdGVyVHlwZShyYXdUeXBlLHtuYW1lOm5hbWUsImZyb21XaXJlVHlwZSI6aGFuZGxlPT57dmFyIHJ2PUVtdmFsLnRvVmFsdWUoaGFuZGxlKTtfX2VtdmFsX2RlY3JlZihoYW5kbGUpO3JldHVybiBydn0sInRvV2lyZVR5cGUiOihkZXN0cnVjdG9ycyx2YWx1ZSk9PkVtdmFsLnRvSGFuZGxlKHZhbHVlKSwiYXJnUGFja0FkdmFuY2UiOkdlbmVyaWNXaXJlVHlwZVNpemUsInJlYWRWYWx1ZUZyb21Qb2ludGVyIjpzaW1wbGVSZWFkVmFsdWVGcm9tUG9pbnRlcixkZXN0cnVjdG9yRnVuY3Rpb246bnVsbH0pO307dmFyIGZsb2F0UmVhZFZhbHVlRnJvbVBvaW50ZXI9KG5hbWUsd2lkdGgpPT57c3dpdGNoKHdpZHRoKXtjYXNlIDQ6cmV0dXJuIGZ1bmN0aW9uKHBvaW50ZXIpe3JldHVybiB0aGlzWyJmcm9tV2lyZVR5cGUiXShIRUFQRjMyW3BvaW50ZXI+PjJdKX07Y2FzZSA4OnJldHVybiBmdW5jdGlvbihwb2ludGVyKXtyZXR1cm4gdGhpc1siZnJvbVdpcmVUeXBlIl0oSEVBUEY2NFtwb2ludGVyPj4zXSl9O2RlZmF1bHQ6dGhyb3cgbmV3IFR5cGVFcnJvcihgaW52YWxpZCBmbG9hdCB3aWR0aCAoJHt3aWR0aH0pOiAke25hbWV9YCl9fTt2YXIgX19lbWJpbmRfcmVnaXN0ZXJfZmxvYXQ9KHJhd1R5cGUsbmFtZSxzaXplKT0+e25hbWU9cmVhZExhdGluMVN0cmluZyhuYW1lKTtyZWdpc3RlclR5cGUocmF3VHlwZSx7bmFtZTpuYW1lLCJmcm9tV2lyZVR5cGUiOnZhbHVlPT52YWx1ZSwidG9XaXJlVHlwZSI6KGRlc3RydWN0b3JzLHZhbHVlKT0+dmFsdWUsImFyZ1BhY2tBZHZhbmNlIjpHZW5lcmljV2lyZVR5cGVTaXplLCJyZWFkVmFsdWVGcm9tUG9pbnRlciI6ZmxvYXRSZWFkVmFsdWVGcm9tUG9pbnRlcihuYW1lLHNpemUpLGRlc3RydWN0b3JGdW5jdGlvbjpudWxsfSk7fTt2YXIgaW50ZWdlclJlYWRWYWx1ZUZyb21Qb2ludGVyPShuYW1lLHdpZHRoLHNpZ25lZCk9Pntzd2l0Y2god2lkdGgpe2Nhc2UgMTpyZXR1cm4gc2lnbmVkP3BvaW50ZXI9PkhFQVA4W3BvaW50ZXI+PjBdOnBvaW50ZXI9PkhFQVBVOFtwb2ludGVyPj4wXTtjYXNlIDI6cmV0dXJuIHNpZ25lZD9wb2ludGVyPT5IRUFQMTZbcG9pbnRlcj4+MV06cG9pbnRlcj0+SEVBUFUxNltwb2ludGVyPj4xXTtjYXNlIDQ6cmV0dXJuIHNpZ25lZD9wb2ludGVyPT5IRUFQMzJbcG9pbnRlcj4+Ml06cG9pbnRlcj0+SEVBUFUzMltwb2ludGVyPj4yXTtkZWZhdWx0OnRocm93IG5ldyBUeXBlRXJyb3IoYGludmFsaWQgaW50ZWdlciB3aWR0aCAoJHt3aWR0aH0pOiAke25hbWV9YCl9fTt2YXIgX19lbWJpbmRfcmVnaXN0ZXJfaW50ZWdlcj0ocHJpbWl0aXZlVHlwZSxuYW1lLHNpemUsbWluUmFuZ2UsbWF4UmFuZ2UpPT57bmFtZT1yZWFkTGF0aW4xU3RyaW5nKG5hbWUpO3ZhciBmcm9tV2lyZVR5cGU9dmFsdWU9PnZhbHVlO2lmKG1pblJhbmdlPT09MCl7dmFyIGJpdHNoaWZ0PTMyLTgqc2l6ZTtmcm9tV2lyZVR5cGU9dmFsdWU9PnZhbHVlPDxiaXRzaGlmdD4+PmJpdHNoaWZ0O312YXIgaXNVbnNpZ25lZFR5cGU9bmFtZS5pbmNsdWRlcygidW5zaWduZWQiKTt2YXIgY2hlY2tBc3NlcnRpb25zPSh2YWx1ZSx0b1R5cGVOYW1lKT0+e307dmFyIHRvV2lyZVR5cGU7aWYoaXNVbnNpZ25lZFR5cGUpe3RvV2lyZVR5cGU9ZnVuY3Rpb24oZGVzdHJ1Y3RvcnMsdmFsdWUpe2NoZWNrQXNzZXJ0aW9ucyh2YWx1ZSx0aGlzLm5hbWUpO3JldHVybiB2YWx1ZT4+PjB9O31lbHNlIHt0b1dpcmVUeXBlPWZ1bmN0aW9uKGRlc3RydWN0b3JzLHZhbHVlKXtjaGVja0Fzc2VydGlvbnModmFsdWUsdGhpcy5uYW1lKTtyZXR1cm4gdmFsdWV9O31yZWdpc3RlclR5cGUocHJpbWl0aXZlVHlwZSx7bmFtZTpuYW1lLCJmcm9tV2lyZVR5cGUiOmZyb21XaXJlVHlwZSwidG9XaXJlVHlwZSI6dG9XaXJlVHlwZSwiYXJnUGFja0FkdmFuY2UiOkdlbmVyaWNXaXJlVHlwZVNpemUsInJlYWRWYWx1ZUZyb21Qb2ludGVyIjppbnRlZ2VyUmVhZFZhbHVlRnJvbVBvaW50ZXIobmFtZSxzaXplLG1pblJhbmdlIT09MCksZGVzdHJ1Y3RvckZ1bmN0aW9uOm51bGx9KTt9O3ZhciBfX2VtYmluZF9yZWdpc3Rlcl9tZW1vcnlfdmlldz0ocmF3VHlwZSxkYXRhVHlwZUluZGV4LG5hbWUpPT57dmFyIHR5cGVNYXBwaW5nPVtJbnQ4QXJyYXksVWludDhBcnJheSxJbnQxNkFycmF5LFVpbnQxNkFycmF5LEludDMyQXJyYXksVWludDMyQXJyYXksRmxvYXQzMkFycmF5LEZsb2F0NjRBcnJheV07dmFyIFRBPXR5cGVNYXBwaW5nW2RhdGFUeXBlSW5kZXhdO2Z1bmN0aW9uIGRlY29kZU1lbW9yeVZpZXcoaGFuZGxlKXt2YXIgc2l6ZT1IRUFQVTMyW2hhbmRsZT4+Ml07dmFyIGRhdGE9SEVBUFUzMltoYW5kbGUrND4+Ml07cmV0dXJuIG5ldyBUQShIRUFQOC5idWZmZXIsZGF0YSxzaXplKX1uYW1lPXJlYWRMYXRpbjFTdHJpbmcobmFtZSk7cmVnaXN0ZXJUeXBlKHJhd1R5cGUse25hbWU6bmFtZSwiZnJvbVdpcmVUeXBlIjpkZWNvZGVNZW1vcnlWaWV3LCJhcmdQYWNrQWR2YW5jZSI6R2VuZXJpY1dpcmVUeXBlU2l6ZSwicmVhZFZhbHVlRnJvbVBvaW50ZXIiOmRlY29kZU1lbW9yeVZpZXd9LHtpZ25vcmVEdXBsaWNhdGVSZWdpc3RyYXRpb25zOnRydWV9KTt9O2Z1bmN0aW9uIHJlYWRQb2ludGVyKHBvaW50ZXIpe3JldHVybiB0aGlzWyJmcm9tV2lyZVR5cGUiXShIRUFQVTMyW3BvaW50ZXI+PjJdKX12YXIgc3RyaW5nVG9VVEY4QXJyYXk9KHN0cixoZWFwLG91dElkeCxtYXhCeXRlc1RvV3JpdGUpPT57aWYoIShtYXhCeXRlc1RvV3JpdGU+MCkpcmV0dXJuIDA7dmFyIHN0YXJ0SWR4PW91dElkeDt2YXIgZW5kSWR4PW91dElkeCttYXhCeXRlc1RvV3JpdGUtMTtmb3IodmFyIGk9MDtpPHN0ci5sZW5ndGg7KytpKXt2YXIgdT1zdHIuY2hhckNvZGVBdChpKTtpZih1Pj01NTI5NiYmdTw9NTczNDMpe3ZhciB1MT1zdHIuY2hhckNvZGVBdCgrK2kpO3U9NjU1MzYrKCh1JjEwMjMpPDwxMCl8dTEmMTAyMzt9aWYodTw9MTI3KXtpZihvdXRJZHg+PWVuZElkeClicmVhaztoZWFwW291dElkeCsrXT11O31lbHNlIGlmKHU8PTIwNDcpe2lmKG91dElkeCsxPj1lbmRJZHgpYnJlYWs7aGVhcFtvdXRJZHgrK109MTkyfHU+PjY7aGVhcFtvdXRJZHgrK109MTI4fHUmNjM7fWVsc2UgaWYodTw9NjU1MzUpe2lmKG91dElkeCsyPj1lbmRJZHgpYnJlYWs7aGVhcFtvdXRJZHgrK109MjI0fHU+PjEyO2hlYXBbb3V0SWR4KytdPTEyOHx1Pj42JjYzO2hlYXBbb3V0SWR4KytdPTEyOHx1JjYzO31lbHNlIHtpZihvdXRJZHgrMz49ZW5kSWR4KWJyZWFrO2hlYXBbb3V0SWR4KytdPTI0MHx1Pj4xODtoZWFwW291dElkeCsrXT0xMjh8dT4+MTImNjM7aGVhcFtvdXRJZHgrK109MTI4fHU+PjYmNjM7aGVhcFtvdXRJZHgrK109MTI4fHUmNjM7fX1oZWFwW291dElkeF09MDtyZXR1cm4gb3V0SWR4LXN0YXJ0SWR4fTt2YXIgc3RyaW5nVG9VVEY4PShzdHIsb3V0UHRyLG1heEJ5dGVzVG9Xcml0ZSk9PnN0cmluZ1RvVVRGOEFycmF5KHN0cixIRUFQVTgsb3V0UHRyLG1heEJ5dGVzVG9Xcml0ZSk7dmFyIGxlbmd0aEJ5dGVzVVRGOD1zdHI9Pnt2YXIgbGVuPTA7Zm9yKHZhciBpPTA7aTxzdHIubGVuZ3RoOysraSl7dmFyIGM9c3RyLmNoYXJDb2RlQXQoaSk7aWYoYzw9MTI3KXtsZW4rKzt9ZWxzZSBpZihjPD0yMDQ3KXtsZW4rPTI7fWVsc2UgaWYoYz49NTUyOTYmJmM8PTU3MzQzKXtsZW4rPTQ7KytpO31lbHNlIHtsZW4rPTM7fX1yZXR1cm4gbGVufTt2YXIgVVRGOERlY29kZXI9dHlwZW9mIFRleHREZWNvZGVyIT0idW5kZWZpbmVkIj9uZXcgVGV4dERlY29kZXIoInV0ZjgiKTp1bmRlZmluZWQ7dmFyIFVURjhBcnJheVRvU3RyaW5nPShoZWFwT3JBcnJheSxpZHgsbWF4Qnl0ZXNUb1JlYWQpPT57dmFyIGVuZElkeD1pZHgrbWF4Qnl0ZXNUb1JlYWQ7dmFyIGVuZFB0cj1pZHg7d2hpbGUoaGVhcE9yQXJyYXlbZW5kUHRyXSYmIShlbmRQdHI+PWVuZElkeCkpKytlbmRQdHI7aWYoZW5kUHRyLWlkeD4xNiYmaGVhcE9yQXJyYXkuYnVmZmVyJiZVVEY4RGVjb2Rlcil7cmV0dXJuIFVURjhEZWNvZGVyLmRlY29kZShoZWFwT3JBcnJheS5zdWJhcnJheShpZHgsZW5kUHRyKSl9dmFyIHN0cj0iIjt3aGlsZShpZHg8ZW5kUHRyKXt2YXIgdTA9aGVhcE9yQXJyYXlbaWR4KytdO2lmKCEodTAmMTI4KSl7c3RyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHUwKTtjb250aW51ZX12YXIgdTE9aGVhcE9yQXJyYXlbaWR4KytdJjYzO2lmKCh1MCYyMjQpPT0xOTIpe3N0cis9U3RyaW5nLmZyb21DaGFyQ29kZSgodTAmMzEpPDw2fHUxKTtjb250aW51ZX12YXIgdTI9aGVhcE9yQXJyYXlbaWR4KytdJjYzO2lmKCh1MCYyNDApPT0yMjQpe3UwPSh1MCYxNSk8PDEyfHUxPDw2fHUyO31lbHNlIHt1MD0odTAmNyk8PDE4fHUxPDwxMnx1Mjw8NnxoZWFwT3JBcnJheVtpZHgrK10mNjM7fWlmKHUwPDY1NTM2KXtzdHIrPVN0cmluZy5mcm9tQ2hhckNvZGUodTApO31lbHNlIHt2YXIgY2g9dTAtNjU1MzY7c3RyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2fGNoPj4xMCw1NjMyMHxjaCYxMDIzKTt9fXJldHVybiBzdHJ9O3ZhciBVVEY4VG9TdHJpbmc9KHB0cixtYXhCeXRlc1RvUmVhZCk9PnB0cj9VVEY4QXJyYXlUb1N0cmluZyhIRUFQVTgscHRyLG1heEJ5dGVzVG9SZWFkKToiIjt2YXIgX19lbWJpbmRfcmVnaXN0ZXJfc3RkX3N0cmluZz0ocmF3VHlwZSxuYW1lKT0+e25hbWU9cmVhZExhdGluMVN0cmluZyhuYW1lKTt2YXIgc3RkU3RyaW5nSXNVVEY4PW5hbWU9PT0ic3RkOjpzdHJpbmciO3JlZ2lzdGVyVHlwZShyYXdUeXBlLHtuYW1lOm5hbWUsImZyb21XaXJlVHlwZSIodmFsdWUpe3ZhciBsZW5ndGg9SEVBUFUzMlt2YWx1ZT4+Ml07dmFyIHBheWxvYWQ9dmFsdWUrNDt2YXIgc3RyO2lmKHN0ZFN0cmluZ0lzVVRGOCl7dmFyIGRlY29kZVN0YXJ0UHRyPXBheWxvYWQ7Zm9yKHZhciBpPTA7aTw9bGVuZ3RoOysraSl7dmFyIGN1cnJlbnRCeXRlUHRyPXBheWxvYWQraTtpZihpPT1sZW5ndGh8fEhFQVBVOFtjdXJyZW50Qnl0ZVB0cl09PTApe3ZhciBtYXhSZWFkPWN1cnJlbnRCeXRlUHRyLWRlY29kZVN0YXJ0UHRyO3ZhciBzdHJpbmdTZWdtZW50PVVURjhUb1N0cmluZyhkZWNvZGVTdGFydFB0cixtYXhSZWFkKTtpZihzdHI9PT11bmRlZmluZWQpe3N0cj1zdHJpbmdTZWdtZW50O31lbHNlIHtzdHIrPVN0cmluZy5mcm9tQ2hhckNvZGUoMCk7c3RyKz1zdHJpbmdTZWdtZW50O31kZWNvZGVTdGFydFB0cj1jdXJyZW50Qnl0ZVB0cisxO319fWVsc2Uge3ZhciBhPW5ldyBBcnJheShsZW5ndGgpO2Zvcih2YXIgaT0wO2k8bGVuZ3RoOysraSl7YVtpXT1TdHJpbmcuZnJvbUNoYXJDb2RlKEhFQVBVOFtwYXlsb2FkK2ldKTt9c3RyPWEuam9pbigiIik7fV9mcmVlKHZhbHVlKTtyZXR1cm4gc3RyfSwidG9XaXJlVHlwZSIoZGVzdHJ1Y3RvcnMsdmFsdWUpe2lmKHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpe3ZhbHVlPW5ldyBVaW50OEFycmF5KHZhbHVlKTt9dmFyIGxlbmd0aDt2YXIgdmFsdWVJc09mVHlwZVN0cmluZz10eXBlb2YgdmFsdWU9PSJzdHJpbmciO2lmKCEodmFsdWVJc09mVHlwZVN0cmluZ3x8dmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5fHx2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5fHx2YWx1ZSBpbnN0YW5jZW9mIEludDhBcnJheSkpe3Rocm93QmluZGluZ0Vycm9yKCJDYW5ub3QgcGFzcyBub24tc3RyaW5nIHRvIHN0ZDo6c3RyaW5nIik7fWlmKHN0ZFN0cmluZ0lzVVRGOCYmdmFsdWVJc09mVHlwZVN0cmluZyl7bGVuZ3RoPWxlbmd0aEJ5dGVzVVRGOCh2YWx1ZSk7fWVsc2Uge2xlbmd0aD12YWx1ZS5sZW5ndGg7fXZhciBiYXNlPV9tYWxsb2MoNCtsZW5ndGgrMSk7dmFyIHB0cj1iYXNlKzQ7SEVBUFUzMltiYXNlPj4yXT1sZW5ndGg7aWYoc3RkU3RyaW5nSXNVVEY4JiZ2YWx1ZUlzT2ZUeXBlU3RyaW5nKXtzdHJpbmdUb1VURjgodmFsdWUscHRyLGxlbmd0aCsxKTt9ZWxzZSB7aWYodmFsdWVJc09mVHlwZVN0cmluZyl7Zm9yKHZhciBpPTA7aTxsZW5ndGg7KytpKXt2YXIgY2hhckNvZGU9dmFsdWUuY2hhckNvZGVBdChpKTtpZihjaGFyQ29kZT4yNTUpe19mcmVlKHB0cik7dGhyb3dCaW5kaW5nRXJyb3IoIlN0cmluZyBoYXMgVVRGLTE2IGNvZGUgdW5pdHMgdGhhdCBkbyBub3QgZml0IGluIDggYml0cyIpO31IRUFQVThbcHRyK2ldPWNoYXJDb2RlO319ZWxzZSB7Zm9yKHZhciBpPTA7aTxsZW5ndGg7KytpKXtIRUFQVThbcHRyK2ldPXZhbHVlW2ldO319fWlmKGRlc3RydWN0b3JzIT09bnVsbCl7ZGVzdHJ1Y3RvcnMucHVzaChfZnJlZSxiYXNlKTt9cmV0dXJuIGJhc2V9LCJhcmdQYWNrQWR2YW5jZSI6R2VuZXJpY1dpcmVUeXBlU2l6ZSwicmVhZFZhbHVlRnJvbVBvaW50ZXIiOnJlYWRQb2ludGVyLGRlc3RydWN0b3JGdW5jdGlvbihwdHIpe19mcmVlKHB0cik7fX0pO307dmFyIFVURjE2RGVjb2Rlcj10eXBlb2YgVGV4dERlY29kZXIhPSJ1bmRlZmluZWQiP25ldyBUZXh0RGVjb2RlcigidXRmLTE2bGUiKTp1bmRlZmluZWQ7dmFyIFVURjE2VG9TdHJpbmc9KHB0cixtYXhCeXRlc1RvUmVhZCk9Pnt2YXIgZW5kUHRyPXB0cjt2YXIgaWR4PWVuZFB0cj4+MTt2YXIgbWF4SWR4PWlkeCttYXhCeXRlc1RvUmVhZC8yO3doaWxlKCEoaWR4Pj1tYXhJZHgpJiZIRUFQVTE2W2lkeF0pKytpZHg7ZW5kUHRyPWlkeDw8MTtpZihlbmRQdHItcHRyPjMyJiZVVEYxNkRlY29kZXIpcmV0dXJuIFVURjE2RGVjb2Rlci5kZWNvZGUoSEVBUFU4LnN1YmFycmF5KHB0cixlbmRQdHIpKTt2YXIgc3RyPSIiO2Zvcih2YXIgaT0wOyEoaT49bWF4Qnl0ZXNUb1JlYWQvMik7KytpKXt2YXIgY29kZVVuaXQ9SEVBUDE2W3B0citpKjI+PjFdO2lmKGNvZGVVbml0PT0wKWJyZWFrO3N0cis9U3RyaW5nLmZyb21DaGFyQ29kZShjb2RlVW5pdCk7fXJldHVybiBzdHJ9O3ZhciBzdHJpbmdUb1VURjE2PShzdHIsb3V0UHRyLG1heEJ5dGVzVG9Xcml0ZSk9PntpZihtYXhCeXRlc1RvV3JpdGU9PT11bmRlZmluZWQpe21heEJ5dGVzVG9Xcml0ZT0yMTQ3NDgzNjQ3O31pZihtYXhCeXRlc1RvV3JpdGU8MilyZXR1cm4gMDttYXhCeXRlc1RvV3JpdGUtPTI7dmFyIHN0YXJ0UHRyPW91dFB0cjt2YXIgbnVtQ2hhcnNUb1dyaXRlPW1heEJ5dGVzVG9Xcml0ZTxzdHIubGVuZ3RoKjI/bWF4Qnl0ZXNUb1dyaXRlLzI6c3RyLmxlbmd0aDtmb3IodmFyIGk9MDtpPG51bUNoYXJzVG9Xcml0ZTsrK2kpe3ZhciBjb2RlVW5pdD1zdHIuY2hhckNvZGVBdChpKTtIRUFQMTZbb3V0UHRyPj4xXT1jb2RlVW5pdDtvdXRQdHIrPTI7fUhFQVAxNltvdXRQdHI+PjFdPTA7cmV0dXJuIG91dFB0ci1zdGFydFB0cn07dmFyIGxlbmd0aEJ5dGVzVVRGMTY9c3RyPT5zdHIubGVuZ3RoKjI7dmFyIFVURjMyVG9TdHJpbmc9KHB0cixtYXhCeXRlc1RvUmVhZCk9Pnt2YXIgaT0wO3ZhciBzdHI9IiI7d2hpbGUoIShpPj1tYXhCeXRlc1RvUmVhZC80KSl7dmFyIHV0ZjMyPUhFQVAzMltwdHIraSo0Pj4yXTtpZih1dGYzMj09MClicmVhazsrK2k7aWYodXRmMzI+PTY1NTM2KXt2YXIgY2g9dXRmMzItNjU1MzY7c3RyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2fGNoPj4xMCw1NjMyMHxjaCYxMDIzKTt9ZWxzZSB7c3RyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHV0ZjMyKTt9fXJldHVybiBzdHJ9O3ZhciBzdHJpbmdUb1VURjMyPShzdHIsb3V0UHRyLG1heEJ5dGVzVG9Xcml0ZSk9PntpZihtYXhCeXRlc1RvV3JpdGU9PT11bmRlZmluZWQpe21heEJ5dGVzVG9Xcml0ZT0yMTQ3NDgzNjQ3O31pZihtYXhCeXRlc1RvV3JpdGU8NClyZXR1cm4gMDt2YXIgc3RhcnRQdHI9b3V0UHRyO3ZhciBlbmRQdHI9c3RhcnRQdHIrbWF4Qnl0ZXNUb1dyaXRlLTQ7Zm9yKHZhciBpPTA7aTxzdHIubGVuZ3RoOysraSl7dmFyIGNvZGVVbml0PXN0ci5jaGFyQ29kZUF0KGkpO2lmKGNvZGVVbml0Pj01NTI5NiYmY29kZVVuaXQ8PTU3MzQzKXt2YXIgdHJhaWxTdXJyb2dhdGU9c3RyLmNoYXJDb2RlQXQoKytpKTtjb2RlVW5pdD02NTUzNisoKGNvZGVVbml0JjEwMjMpPDwxMCl8dHJhaWxTdXJyb2dhdGUmMTAyMzt9SEVBUDMyW291dFB0cj4+Ml09Y29kZVVuaXQ7b3V0UHRyKz00O2lmKG91dFB0cis0PmVuZFB0cilicmVha31IRUFQMzJbb3V0UHRyPj4yXT0wO3JldHVybiBvdXRQdHItc3RhcnRQdHJ9O3ZhciBsZW5ndGhCeXRlc1VURjMyPXN0cj0+e3ZhciBsZW49MDtmb3IodmFyIGk9MDtpPHN0ci5sZW5ndGg7KytpKXt2YXIgY29kZVVuaXQ9c3RyLmNoYXJDb2RlQXQoaSk7aWYoY29kZVVuaXQ+PTU1Mjk2JiZjb2RlVW5pdDw9NTczNDMpKytpO2xlbis9NDt9cmV0dXJuIGxlbn07dmFyIF9fZW1iaW5kX3JlZ2lzdGVyX3N0ZF93c3RyaW5nPShyYXdUeXBlLGNoYXJTaXplLG5hbWUpPT57bmFtZT1yZWFkTGF0aW4xU3RyaW5nKG5hbWUpO3ZhciBkZWNvZGVTdHJpbmcsZW5jb2RlU3RyaW5nLGdldEhlYXAsbGVuZ3RoQnl0ZXNVVEYsc2hpZnQ7aWYoY2hhclNpemU9PT0yKXtkZWNvZGVTdHJpbmc9VVRGMTZUb1N0cmluZztlbmNvZGVTdHJpbmc9c3RyaW5nVG9VVEYxNjtsZW5ndGhCeXRlc1VURj1sZW5ndGhCeXRlc1VURjE2O2dldEhlYXA9KCk9PkhFQVBVMTY7c2hpZnQ9MTt9ZWxzZSBpZihjaGFyU2l6ZT09PTQpe2RlY29kZVN0cmluZz1VVEYzMlRvU3RyaW5nO2VuY29kZVN0cmluZz1zdHJpbmdUb1VURjMyO2xlbmd0aEJ5dGVzVVRGPWxlbmd0aEJ5dGVzVVRGMzI7Z2V0SGVhcD0oKT0+SEVBUFUzMjtzaGlmdD0yO31yZWdpc3RlclR5cGUocmF3VHlwZSx7bmFtZTpuYW1lLCJmcm9tV2lyZVR5cGUiOnZhbHVlPT57dmFyIGxlbmd0aD1IRUFQVTMyW3ZhbHVlPj4yXTt2YXIgSEVBUD1nZXRIZWFwKCk7dmFyIHN0cjt2YXIgZGVjb2RlU3RhcnRQdHI9dmFsdWUrNDtmb3IodmFyIGk9MDtpPD1sZW5ndGg7KytpKXt2YXIgY3VycmVudEJ5dGVQdHI9dmFsdWUrNCtpKmNoYXJTaXplO2lmKGk9PWxlbmd0aHx8SEVBUFtjdXJyZW50Qnl0ZVB0cj4+c2hpZnRdPT0wKXt2YXIgbWF4UmVhZEJ5dGVzPWN1cnJlbnRCeXRlUHRyLWRlY29kZVN0YXJ0UHRyO3ZhciBzdHJpbmdTZWdtZW50PWRlY29kZVN0cmluZyhkZWNvZGVTdGFydFB0cixtYXhSZWFkQnl0ZXMpO2lmKHN0cj09PXVuZGVmaW5lZCl7c3RyPXN0cmluZ1NlZ21lbnQ7fWVsc2Uge3N0cis9U3RyaW5nLmZyb21DaGFyQ29kZSgwKTtzdHIrPXN0cmluZ1NlZ21lbnQ7fWRlY29kZVN0YXJ0UHRyPWN1cnJlbnRCeXRlUHRyK2NoYXJTaXplO319X2ZyZWUodmFsdWUpO3JldHVybiBzdHJ9LCJ0b1dpcmVUeXBlIjooZGVzdHJ1Y3RvcnMsdmFsdWUpPT57aWYoISh0eXBlb2YgdmFsdWU9PSJzdHJpbmciKSl7dGhyb3dCaW5kaW5nRXJyb3IoYENhbm5vdCBwYXNzIG5vbi1zdHJpbmcgdG8gQysrIHN0cmluZyB0eXBlICR7bmFtZX1gKTt9dmFyIGxlbmd0aD1sZW5ndGhCeXRlc1VURih2YWx1ZSk7dmFyIHB0cj1fbWFsbG9jKDQrbGVuZ3RoK2NoYXJTaXplKTtIRUFQVTMyW3B0cj4+Ml09bGVuZ3RoPj5zaGlmdDtlbmNvZGVTdHJpbmcodmFsdWUscHRyKzQsbGVuZ3RoK2NoYXJTaXplKTtpZihkZXN0cnVjdG9ycyE9PW51bGwpe2Rlc3RydWN0b3JzLnB1c2goX2ZyZWUscHRyKTt9cmV0dXJuIHB0cn0sImFyZ1BhY2tBZHZhbmNlIjpHZW5lcmljV2lyZVR5cGVTaXplLCJyZWFkVmFsdWVGcm9tUG9pbnRlciI6c2ltcGxlUmVhZFZhbHVlRnJvbVBvaW50ZXIsZGVzdHJ1Y3RvckZ1bmN0aW9uKHB0cil7X2ZyZWUocHRyKTt9fSk7fTt2YXIgX19lbWJpbmRfcmVnaXN0ZXJfdm9pZD0ocmF3VHlwZSxuYW1lKT0+e25hbWU9cmVhZExhdGluMVN0cmluZyhuYW1lKTtyZWdpc3RlclR5cGUocmF3VHlwZSx7aXNWb2lkOnRydWUsbmFtZTpuYW1lLCJhcmdQYWNrQWR2YW5jZSI6MCwiZnJvbVdpcmVUeXBlIjooKT0+dW5kZWZpbmVkLCJ0b1dpcmVUeXBlIjooZGVzdHJ1Y3RvcnMsbyk9PnVuZGVmaW5lZH0pO307dmFyIGdldEhlYXBNYXg9KCk9PjIxNDc0ODM2NDg7dmFyIGdyb3dNZW1vcnk9c2l6ZT0+e3ZhciBiPXdhc21NZW1vcnkuYnVmZmVyO3ZhciBwYWdlcz0oc2l6ZS1iLmJ5dGVMZW5ndGgrNjU1MzUpLzY1NTM2O3RyeXt3YXNtTWVtb3J5Lmdyb3cocGFnZXMpO3VwZGF0ZU1lbW9yeVZpZXdzKCk7cmV0dXJuIDF9Y2F0Y2goZSl7fX07dmFyIF9lbXNjcmlwdGVuX3Jlc2l6ZV9oZWFwPXJlcXVlc3RlZFNpemU9Pnt2YXIgb2xkU2l6ZT1IRUFQVTgubGVuZ3RoO3JlcXVlc3RlZFNpemU+Pj49MDt2YXIgbWF4SGVhcFNpemU9Z2V0SGVhcE1heCgpO2lmKHJlcXVlc3RlZFNpemU+bWF4SGVhcFNpemUpe3JldHVybiBmYWxzZX12YXIgYWxpZ25VcD0oeCxtdWx0aXBsZSk9PngrKG11bHRpcGxlLXglbXVsdGlwbGUpJW11bHRpcGxlO2Zvcih2YXIgY3V0RG93bj0xO2N1dERvd248PTQ7Y3V0RG93bio9Mil7dmFyIG92ZXJHcm93bkhlYXBTaXplPW9sZFNpemUqKDErLjIvY3V0RG93bik7b3Zlckdyb3duSGVhcFNpemU9TWF0aC5taW4ob3Zlckdyb3duSGVhcFNpemUscmVxdWVzdGVkU2l6ZSsxMDA2NjMyOTYpO3ZhciBuZXdTaXplPU1hdGgubWluKG1heEhlYXBTaXplLGFsaWduVXAoTWF0aC5tYXgocmVxdWVzdGVkU2l6ZSxvdmVyR3Jvd25IZWFwU2l6ZSksNjU1MzYpKTt2YXIgcmVwbGFjZW1lbnQ9Z3Jvd01lbW9yeShuZXdTaXplKTtpZihyZXBsYWNlbWVudCl7cmV0dXJuIHRydWV9fXJldHVybiBmYWxzZX07ZW1iaW5kX2luaXRfY2hhckNvZGVzKCk7QmluZGluZ0Vycm9yPU1vZHVsZVsiQmluZGluZ0Vycm9yIl09Y2xhc3MgQmluZGluZ0Vycm9yIGV4dGVuZHMgRXJyb3J7Y29uc3RydWN0b3IobWVzc2FnZSl7c3VwZXIobWVzc2FnZSk7dGhpcy5uYW1lPSJCaW5kaW5nRXJyb3IiO319O01vZHVsZVsiSW50ZXJuYWxFcnJvciJdPWNsYXNzIEludGVybmFsRXJyb3IgZXh0ZW5kcyBFcnJvcntjb25zdHJ1Y3RvcihtZXNzYWdlKXtzdXBlcihtZXNzYWdlKTt0aGlzLm5hbWU9IkludGVybmFsRXJyb3IiO319O2hhbmRsZUFsbG9jYXRvckluaXQoKTtpbml0X2VtdmFsKCk7dmFyIHdhc21JbXBvcnRzPXtmOl9fZW1iaW5kX3JlZ2lzdGVyX2JpZ2ludCxpOl9fZW1iaW5kX3JlZ2lzdGVyX2Jvb2wsaDpfX2VtYmluZF9yZWdpc3Rlcl9lbXZhbCxlOl9fZW1iaW5kX3JlZ2lzdGVyX2Zsb2F0LGI6X19lbWJpbmRfcmVnaXN0ZXJfaW50ZWdlcixhOl9fZW1iaW5kX3JlZ2lzdGVyX21lbW9yeV92aWV3LGQ6X19lbWJpbmRfcmVnaXN0ZXJfc3RkX3N0cmluZyxjOl9fZW1iaW5kX3JlZ2lzdGVyX3N0ZF93c3RyaW5nLGo6X19lbWJpbmRfcmVnaXN0ZXJfdm9pZCxnOl9lbXNjcmlwdGVuX3Jlc2l6ZV9oZWFwfTt2YXIgd2FzbUV4cG9ydHM9Y3JlYXRlV2FzbSgpO01vZHVsZVsiX3NvcnQiXT0oYTAsYTEsYTIsYTMsYTQsYTUsYTYpPT4oTW9kdWxlWyJfc29ydCJdPXdhc21FeHBvcnRzWyJtIl0pKGEwLGExLGEyLGEzLGE0LGE1LGE2KTt2YXIgX21hbGxvYz1Nb2R1bGVbIl9tYWxsb2MiXT1hMD0+KF9tYWxsb2M9TW9kdWxlWyJfbWFsbG9jIl09d2FzbUV4cG9ydHNbIm8iXSkoYTApO3ZhciBfZnJlZT1Nb2R1bGVbIl9mcmVlIl09YTA9PihfZnJlZT1Nb2R1bGVbIl9mcmVlIl09d2FzbUV4cG9ydHNbInAiXSkoYTApO3ZhciBjYWxsZWRSdW47ZGVwZW5kZW5jaWVzRnVsZmlsbGVkPWZ1bmN0aW9uIHJ1bkNhbGxlcigpe2lmKCFjYWxsZWRSdW4pcnVuKCk7aWYoIWNhbGxlZFJ1bilkZXBlbmRlbmNpZXNGdWxmaWxsZWQ9cnVuQ2FsbGVyO307ZnVuY3Rpb24gcnVuKCl7aWYocnVuRGVwZW5kZW5jaWVzPjApe3JldHVybn1wcmVSdW4oKTtpZihydW5EZXBlbmRlbmNpZXM+MCl7cmV0dXJufWZ1bmN0aW9uIGRvUnVuKCl7aWYoY2FsbGVkUnVuKXJldHVybjtjYWxsZWRSdW49dHJ1ZTtNb2R1bGVbImNhbGxlZFJ1biJdPXRydWU7aWYoQUJPUlQpcmV0dXJuO2luaXRSdW50aW1lKCk7cmVhZHlQcm9taXNlUmVzb2x2ZShNb2R1bGUpO2lmKE1vZHVsZVsib25SdW50aW1lSW5pdGlhbGl6ZWQiXSlNb2R1bGVbIm9uUnVudGltZUluaXRpYWxpemVkIl0oKTtwb3N0UnVuKCk7fWlmKE1vZHVsZVsic2V0U3RhdHVzIl0pe01vZHVsZVsic2V0U3RhdHVzIl0oIlJ1bm5pbmcuLi4iKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7c2V0VGltZW91dChmdW5jdGlvbigpe01vZHVsZVsic2V0U3RhdHVzIl0oIiIpO30sMSk7ZG9SdW4oKTt9LDEpO31lbHNlIHtkb1J1bigpO319aWYoTW9kdWxlWyJwcmVJbml0Il0pe2lmKHR5cGVvZiBNb2R1bGVbInByZUluaXQiXT09ImZ1bmN0aW9uIilNb2R1bGVbInByZUluaXQiXT1bTW9kdWxlWyJwcmVJbml0Il1dO3doaWxlKE1vZHVsZVsicHJlSW5pdCJdLmxlbmd0aD4wKXtNb2R1bGVbInByZUluaXQiXS5wb3AoKSgpO319cnVuKCk7CgoKICAgIHJldHVybiBtb2R1bGVBcmcucmVhZHkKICB9CiAgKTsKICB9KSgpOwoKICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueQogIGxldCB3YXNtTW9kdWxlOwogIGFzeW5jIGZ1bmN0aW9uIGluaXRXYXNtKCkgewogICAgICB3YXNtTW9kdWxlID0gYXdhaXQgbG9hZFdhc20oKTsKICB9CiAgbGV0IHNvcnREYXRhOwogIGxldCB2aWV3UHJvajsKICBsZXQgc29ydFJ1bm5pbmcgPSBmYWxzZTsKICBsZXQgdmlld1Byb2pQdHI7CiAgbGV0IGZCdWZmZXJQdHI7CiAgbGV0IGRlcHRoQnVmZmVyUHRyOwogIGxldCBkZXB0aEluZGV4UHRyOwogIGxldCBzdGFydHNQdHI7CiAgbGV0IGNvdW50c1B0cjsKICBjb25zdCBpbml0U2NlbmUgPSBhc3luYyAoKSA9PiB7CiAgICAgIGlmICghd2FzbU1vZHVsZSkKICAgICAgICAgIGF3YWl0IGluaXRXYXNtKCk7CiAgICAgIGZCdWZmZXJQdHIgPSB3YXNtTW9kdWxlLl9tYWxsb2Moc29ydERhdGEucG9zaXRpb25zLmxlbmd0aCAqIHNvcnREYXRhLnBvc2l0aW9ucy5CWVRFU19QRVJfRUxFTUVOVCk7CiAgICAgIHdhc21Nb2R1bGUuSEVBUEYzMi5zZXQoc29ydERhdGEucG9zaXRpb25zLCBmQnVmZmVyUHRyIC8gNCk7CiAgICAgIHZpZXdQcm9qUHRyID0gd2FzbU1vZHVsZS5fbWFsbG9jKDE2ICogNCk7CiAgICAgIGRlcHRoQnVmZmVyUHRyID0gd2FzbU1vZHVsZS5fbWFsbG9jKHNvcnREYXRhLnZlcnRleENvdW50ICogNCk7CiAgICAgIGRlcHRoSW5kZXhQdHIgPSB3YXNtTW9kdWxlLl9tYWxsb2Moc29ydERhdGEudmVydGV4Q291bnQgKiA0KTsKICAgICAgc3RhcnRzUHRyID0gd2FzbU1vZHVsZS5fbWFsbG9jKHNvcnREYXRhLnZlcnRleENvdW50ICogNCk7CiAgICAgIGNvdW50c1B0ciA9IHdhc21Nb2R1bGUuX21hbGxvYyhzb3J0RGF0YS52ZXJ0ZXhDb3VudCAqIDQpOwogIH07CiAgY29uc3QgcnVuU29ydCA9ICh2aWV3UHJvaikgPT4gewogICAgICBjb25zdCB2aWV3UHJvakJ1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkodmlld1Byb2ouYnVmZmVyKTsKICAgICAgd2FzbU1vZHVsZS5IRUFQRjMyLnNldCh2aWV3UHJvakJ1ZmZlciwgdmlld1Byb2pQdHIgLyA0KTsKICAgICAgd2FzbU1vZHVsZS5fc29ydCh2aWV3UHJvalB0ciwgc29ydERhdGEudmVydGV4Q291bnQsIGZCdWZmZXJQdHIsIGRlcHRoQnVmZmVyUHRyLCBkZXB0aEluZGV4UHRyLCBzdGFydHNQdHIsIGNvdW50c1B0cik7CiAgICAgIGNvbnN0IGRlcHRoSW5kZXggPSBuZXcgVWludDMyQXJyYXkod2FzbU1vZHVsZS5IRUFQVTMyLmJ1ZmZlciwgZGVwdGhJbmRleFB0ciwgc29ydERhdGEudmVydGV4Q291bnQpOwogICAgICBjb25zdCB0cmFuc2ZlcmFibGVEZXB0aEluZGV4ID0gbmV3IFVpbnQzMkFycmF5KGRlcHRoSW5kZXguc2xpY2UoKSk7CiAgICAgIHNlbGYucG9zdE1lc3NhZ2UoeyBkZXB0aEluZGV4OiB0cmFuc2ZlcmFibGVEZXB0aEluZGV4IH0sIFt0cmFuc2ZlcmFibGVEZXB0aEluZGV4LmJ1ZmZlcl0pOwogIH07CiAgY29uc3QgdGhyb3R0bGVkU29ydCA9ICgpID0+IHsKICAgICAgaWYgKCFzb3J0UnVubmluZykgewogICAgICAgICAgc29ydFJ1bm5pbmcgPSB0cnVlOwogICAgICAgICAgY29uc3QgbGFzdFZpZXcgPSB2aWV3UHJvajsKICAgICAgICAgIHJ1blNvcnQobGFzdFZpZXcpOwogICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7CiAgICAgICAgICAgICAgc29ydFJ1bm5pbmcgPSBmYWxzZTsKICAgICAgICAgICAgICBpZiAobGFzdFZpZXcgIT09IHZpZXdQcm9qKSB7CiAgICAgICAgICAgICAgICAgIHRocm90dGxlZFNvcnQoKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICB9LCAwKTsKICAgICAgfQogIH07CiAgc2VsZi5vbm1lc3NhZ2UgPSAoZSkgPT4gewogICAgICBpZiAoZS5kYXRhLnNvcnREYXRhKSB7CiAgICAgICAgICBzb3J0RGF0YSA9IGUuZGF0YS5zb3J0RGF0YTsKICAgICAgICAgIGluaXRTY2VuZSgpOwogICAgICB9CiAgICAgIGlmICghc29ydERhdGEgfHwgIXdhc21Nb2R1bGUpCiAgICAgICAgICByZXR1cm47CiAgICAgIGlmIChlLmRhdGEudmlld1Byb2opIHsKICAgICAgICAgIHZpZXdQcm9qID0gZS5kYXRhLnZpZXdQcm9qOwogICAgICAgICAgdGhyb3R0bGVkU29ydCgpOwogICAgICB9CiAgfTsKCn0pKCk7Ci8vIyBzb3VyY2VNYXBwaW5nVVJMPVdvcmtlci5qcy5tYXAKCg==",UU=null,FU=!1,function(b){return P=P||eU($,UU,FU),new Worker(P,b)});class iU{constructor(l=1){let U,t,F,V=0,R=!1;this.init=(W,Q)=>{V=0,R=!0,U=W,t=W.gl.getUniformLocation(Q,"u_useDepthFade"),U.gl.uniform1i(t,1),F=W.gl.getUniformLocation(Q,"u_depthFade"),U.gl.uniform1f(F,V)},this.render=()=>{R&&(V=Math.min(V+.01*l,1),V>=1&&(R=!1,U.gl.uniform1i(t,0)),U.gl.uniform1f(F,V))}}}class cU{constructor(l){const U=new Float32Array(1),t=new Int32Array(U.buffer),F=Q=>{U[0]=Q;const Z=t[0],d=Z>>23&255;let e,B=8388607&Z;return d==0?e=0:d<113?(e=0,B|=8388608,B>>=113-d,16777216&B&&(e=1,B=0)):d<142?e=d-112:(e=31,B=0),(Z>>31&1)<<15|e<<10|B>>13},V=(Q,Z)=>(F(Q)|F(Z)<<16)>>>0;this._width=2048,this._height=Math.ceil(2*l.vertexCount/this._width),this._buffer=new Uint32Array(this._width*this._height*4);const R=new Float32Array(this._buffer.buffer),W=new Uint8Array(this._buffer.buffer);for(let Q=0;Q<l.vertexCount;Q++){R[8*Q+0]=l.positions[3*Q+0],R[8*Q+1]=l.positions[3*Q+1],R[8*Q+2]=l.positions[3*Q+2],W[4*(8*Q+7)+0]=l.colors[4*Q+0],W[4*(8*Q+7)+1]=l.colors[4*Q+1],W[4*(8*Q+7)+2]=l.colors[4*Q+2],W[4*(8*Q+7)+3]=l.colors[4*Q+3];const Z=G.RotationFromQuaternion(new Y(l.rotations[4*Q+1],l.rotations[4*Q+2],l.rotations[4*Q+3],-l.rotations[4*Q+0])),d=G.Diagonal(new h(l.scales[3*Q+0],l.scales[3*Q+1],l.scales[3*Q+2])).multiply(Z).buffer,e=[d[0]*d[0]+d[3]*d[3]+d[6]*d[6],d[0]*d[1]+d[3]*d[4]+d[6]*d[7],d[0]*d[2]+d[3]*d[5]+d[6]*d[8],d[1]*d[1]+d[4]*d[4]+d[7]*d[7],d[1]*d[2]+d[4]*d[5]+d[7]*d[8],d[2]*d[2]+d[5]*d[5]+d[8]*d[8]];this._buffer[8*Q+4]=V(4*e[0],4*e[1]),this._buffer[8*Q+5]=V(4*e[2],4*e[3]),this._buffer[8*Q+6]=V(4*e[4],4*e[5])}}get buffer(){return this._buffer}get width(){return this._width}get height(){return this._height}}class hU{constructor(l=null,U=null){const t=l||document.createElement("canvas");l||(t.style.display="block",t.style.boxSizing="border-box",t.style.width="100%",t.style.height="100%",t.style.margin="0",t.style.padding="0",document.body.appendChild(t)),t.style.background="#000",this.domElement=t;const F=t.getContext("webgl2",{antialias:!1});this.gl=F;const V=U||[];let R,W,Q,Z,d,e,B,a,y,k,N,p,J,i;U||V.push(new iU);let T=!1;this.resize=()=>{const r=t.clientWidth,S=t.clientHeight;t.width===r&&t.height===S||this.setSize(r,S)},this.setSize=(r,S)=>{t.width=r,t.height=S,W&&(F.viewport(0,0,t.width,t.height),W.update(t.width,t.height),B=F.getUniformLocation(e,"projection"),F.uniformMatrix4fv(B,!1,W.projectionMatrix.buffer),a=F.getUniformLocation(e,"viewport"),F.uniform2fv(a,new Float32Array([t.width,t.height])))};const w=()=>{Q=new BU;const r={positions:R.positions,vertexCount:R.vertexCount};Q.postMessage({sortData:r}),F.viewport(0,0,t.width,t.height),Z=F.createShader(F.VERTEX_SHADER),F.shaderSource(Z,`#version 300 es
precision highp float;
precision highp int;

uniform highp usampler2D u_texture;
uniform mat4 projection, view;
uniform vec2 focal;
uniform vec2 viewport;

uniform bool u_useDepthFade;
uniform float u_depthFade;

in vec2 position;
in int index;

out vec4 vColor;
out vec2 vPosition;

void main () {
    uvec4 cen = texelFetch(u_texture, ivec2((uint(index) & 0x3ffu) << 1, uint(index) >> 10), 0);
    vec4 cam = view * vec4(uintBitsToFloat(cen.xyz), 1);
    vec4 pos2d = projection * cam;

    float clip = 1.2 * pos2d.w;
    if (pos2d.z < -pos2d.w || pos2d.x < -clip || pos2d.x > clip || pos2d.y < -clip || pos2d.y > clip) {
        gl_Position = vec4(0.0, 0.0, 2.0, 1.0);
        return;
    }


    uvec4 cov = texelFetch(u_texture, ivec2(((uint(index) & 0x3ffu) << 1) | 1u, uint(index) >> 10), 0);
    vec2 u1 = unpackHalf2x16(cov.x), u2 = unpackHalf2x16(cov.y), u3 = unpackHalf2x16(cov.z);
    mat3 Vrk = mat3(u1.x, u1.y, u2.x, u1.y, u2.y, u3.x, u2.x, u3.x, u3.y);

    mat3 J = mat3(
        focal.x / cam.z, 0., -(focal.x * cam.x) / (cam.z * cam.z), 
        0., -focal.y / cam.z, (focal.y * cam.y) / (cam.z * cam.z), 
        0., 0., 0.
    );

    mat3 T = transpose(mat3(view)) * J;
    mat3 cov2d = transpose(T) * Vrk * T;

    float mid = (cov2d[0][0] + cov2d[1][1]) / 2.0;
    float radius = length(vec2((cov2d[0][0] - cov2d[1][1]) / 2.0, cov2d[0][1]));
    float lambda1 = mid + radius, lambda2 = mid - radius;

    if(lambda2 < 0.0) return;
    vec2 diagonalVector = normalize(vec2(cov2d[0][1], lambda1 - cov2d[0][0]));
    vec2 majorAxis = min(sqrt(2.0 * lambda1), 1024.0) * diagonalVector;
    vec2 minorAxis = min(sqrt(2.0 * lambda2), 1024.0) * vec2(diagonalVector.y, -diagonalVector.x);

    vColor = vec4((cov.w) & 0xffu, (cov.w >> 8) & 0xffu, (cov.w >> 16) & 0xffu, (cov.w >> 24) & 0xffu) / 255.0;
    vPosition = position;

    float scalingFactor = 1.0;

    if(u_useDepthFade) {
        float depthNorm = (pos2d.z / pos2d.w + 1.0) / 2.0;
        float near = 0.1; float far = 100.0;
        float normalizedDepth = (2.0 * near) / (far + near - depthNorm * (far - near));
        float start = max(normalizedDepth - 0.1, 0.0);
        float end = min(normalizedDepth + 0.1, 1.0);
        scalingFactor = clamp((u_depthFade - start) / (end - start), 0.0, 1.0);
    }

    vec2 vCenter = vec2(pos2d) / pos2d.w;
    gl_Position = vec4(
        vCenter 
        + position.x * majorAxis * scalingFactor / viewport 
        + position.y * minorAxis * scalingFactor / viewport, 0.0, 1.0);

}
`),F.compileShader(Z),F.getShaderParameter(Z,F.COMPILE_STATUS)||console.error(F.getShaderInfoLog(Z)),d=F.createShader(F.FRAGMENT_SHADER),F.shaderSource(d,`#version 300 es
precision highp float;

in vec4 vColor;
in vec2 vPosition;

out vec4 fragColor;

void main () {
    float A = -dot(vPosition, vPosition);
    if (A < -4.0) discard;
    float B = exp(A) * vColor.a;
    fragColor = vec4(B * vColor.rgb, B);
}
`),F.compileShader(d),F.getShaderParameter(d,F.COMPILE_STATUS)||console.error(F.getShaderInfoLog(d)),e=F.createProgram(),F.attachShader(e,Z),F.attachShader(e,d),F.linkProgram(e),F.useProgram(e),F.getProgramParameter(e,F.LINK_STATUS)||console.error(F.getProgramInfoLog(e)),F.disable(F.DEPTH_TEST),F.enable(F.BLEND),F.blendFuncSeparate(F.ONE_MINUS_DST_ALPHA,F.ONE,F.ONE_MINUS_DST_ALPHA,F.ONE),F.blendEquationSeparate(F.FUNC_ADD,F.FUNC_ADD),W.update(t.width,t.height),B=F.getUniformLocation(e,"projection"),F.uniformMatrix4fv(B,!1,W.projectionMatrix.buffer),a=F.getUniformLocation(e,"viewport"),F.uniform2fv(a,new Float32Array([t.width,t.height])),y=F.getUniformLocation(e,"focal"),F.uniform2fv(y,new Float32Array([W.fx,W.fy])),k=F.getUniformLocation(e,"view"),F.uniformMatrix4fv(k,!1,W.viewMatrix.buffer);const S=new Float32Array([-2,-2,2,-2,2,2,-2,2]);i=F.createBuffer(),F.bindBuffer(F.ARRAY_BUFFER,i),F.bufferData(F.ARRAY_BUFFER,S,F.STATIC_DRAW),p=F.getAttribLocation(e,"position"),F.enableVertexAttribArray(p),F.vertexAttribPointer(p,2,F.FLOAT,!1,0,0);const C=F.createTexture();F.bindTexture(F.TEXTURE_2D,C),N=F.getUniformLocation(e,"u_texture"),F.uniform1i(N,0);const K=F.createBuffer();J=F.getAttribLocation(e,"index"),F.enableVertexAttribArray(J),F.bindBuffer(F.ARRAY_BUFFER,K),F.vertexAttribIPointer(J,1,F.INT,0,0),F.vertexAttribDivisor(J,1);const v=new cU(R);F.bindTexture(F.TEXTURE_2D,C),F.texParameteri(F.TEXTURE_2D,F.TEXTURE_WRAP_S,F.CLAMP_TO_EDGE),F.texParameteri(F.TEXTURE_2D,F.TEXTURE_WRAP_T,F.CLAMP_TO_EDGE),F.texParameteri(F.TEXTURE_2D,F.TEXTURE_MIN_FILTER,F.NEAREST),F.texParameteri(F.TEXTURE_2D,F.TEXTURE_MAG_FILTER,F.NEAREST),F.texImage2D(F.TEXTURE_2D,0,F.RGBA32UI,v.width,v.height,0,F.RGBA_INTEGER,F.UNSIGNED_INT,v.buffer),F.activeTexture(F.TEXTURE0),F.bindTexture(F.TEXTURE_2D,C);for(const g of V)g.init(this,e);Q.onmessage=g=>{if(g.data.depthIndex){const{depthIndex:f}=g.data;F.bindBuffer(F.ARRAY_BUFFER,K),F.bufferData(F.ARRAY_BUFFER,f,F.STATIC_DRAW)}},T=!0},x=()=>{T&&this.dispose(),w()};this.render=(r,S)=>{if(r===R&&S===W||(T&&this.dispose(),W=S,r!==R&&(R&&R.removeEventListener("change",x),R=r,R.addEventListener("change",x)),w()),W.update(t.width,t.height),Q.postMessage({viewProj:W.viewProj}),R.vertexCount>0){for(const C of V)C.render();F.uniformMatrix4fv(k,!1,W.viewMatrix.buffer),F.clear(F.COLOR_BUFFER_BIT),F.drawArraysInstanced(F.TRIANGLE_FAN,0,4,R.vertexCount)}else F.clear(F.COLOR_BUFFER_BIT)},this.dispose=()=>{T&&(Q.terminate(),F.deleteShader(Z),F.deleteShader(d),F.deleteProgram(e),F.deleteBuffer(i),F.deleteBuffer(void 0),F.deleteBuffer(void 0),F.deleteBuffer(void 0),F.deleteBuffer(void 0),T=!1)},this.resize()}}class JU{constructor(l,U,t=.5,F=.5,V=5,R=!0,W=new h){this.minAngle=-90,this.maxAngle=90,this.minZoom=.1,this.maxZoom=30,this.orbitSpeed=1,this.panSpeed=1,this.zoomSpeed=1,this.dampening=.12,this.setCameraTarget=()=>{},this.attach=()=>{},this.detach=()=>{};let Q=W.clone(),Z=Q.clone(),d=t,e=F,B=V,a=!1,y=!1,k=0,N=0,p=0;const J={};let i=null,T=!1;const w=()=>{if(!i||T)return;const n=i.rotation.toEuler();d=-n.y,e=-n.x;const c=i.position.x-B*Math.sin(d)*Math.cos(e),s=i.position.y+B*Math.sin(e),m=i.position.z+B*Math.cos(d)*Math.cos(e);Z=new h(c,s,m)};this.attach=n=>{i&&this.detach(),i=n,i.addEventListener("change",w)},this.detach=()=>{i&&(i.removeEventListener("change",w),i=null)},this.attach(l),this.setCameraTarget=n=>{if(!i)return;const c=n.x-i.position.x,s=n.y-i.position.y,m=n.z-i.position.z;B=Math.sqrt(c*c+s*s+m*m),e=Math.atan2(s,Math.sqrt(c*c+m*m)),d=-Math.atan2(c,m),Z=new h(n.x,n.y,n.z)};const x=()=>.1+.9*(B-this.minZoom)/(this.maxZoom-this.minZoom),r=n=>{J[n.code]=!0,n.code==="ArrowUp"&&(J.KeyW=!0),n.code==="ArrowDown"&&(J.KeyS=!0),n.code==="ArrowLeft"&&(J.KeyA=!0),n.code==="ArrowRight"&&(J.KeyD=!0)},S=n=>{J[n.code]=!1,n.code==="ArrowUp"&&(J.KeyW=!1),n.code==="ArrowDown"&&(J.KeyS=!1),n.code==="ArrowLeft"&&(J.KeyA=!1),n.code==="ArrowRight"&&(J.KeyD=!1)},C=n=>{o(n),a=!0,y=n.button===2,N=n.clientX,p=n.clientY,window.addEventListener("mouseup",K)},K=n=>{o(n),a=!1,y=!1,window.removeEventListener("mouseup",K)},v=n=>{if(o(n),!a||!i)return;const c=n.clientX-N,s=n.clientY-p;if(y){const m=x(),M=-c*this.panSpeed*.01*m,z=-s*this.panSpeed*.01*m,X=G.RotationFromQuaternion(i.rotation).buffer,E=new h(X[0],X[3],X[6]),u=new h(X[1],X[4],X[7]);Z=Z.add(E.multiply(M)),Z=Z.add(u.multiply(z))}else d-=c*this.orbitSpeed*.003,e+=s*this.orbitSpeed*.003,e=Math.min(Math.max(e,this.minAngle*Math.PI/180),this.maxAngle*Math.PI/180);N=n.clientX,p=n.clientY},g=n=>{o(n);const c=x();B+=n.deltaY*this.zoomSpeed*.025*c,B=Math.min(Math.max(B,this.minZoom),this.maxZoom)},f=n=>{if(o(n),n.touches.length===1)a=!0,y=!1,N=n.touches[0].clientX,p=n.touches[0].clientY,k=0;else if(n.touches.length===2){a=!0,y=!0,N=(n.touches[0].clientX+n.touches[1].clientX)/2,p=(n.touches[0].clientY+n.touches[1].clientY)/2;const c=n.touches[0].clientX-n.touches[1].clientX,s=n.touches[0].clientY-n.touches[1].clientY;k=Math.sqrt(c*c+s*s)}},_=n=>{o(n),a=!1,y=!1},q=n=>{if(o(n),a&&i)if(y){const c=x(),s=n.touches[0].clientX-n.touches[1].clientX,m=n.touches[0].clientY-n.touches[1].clientY,M=Math.sqrt(s*s+m*m);B+=(k-M)*this.zoomSpeed*.1*c,B=Math.min(Math.max(B,this.minZoom),this.maxZoom),k=M;const z=(n.touches[0].clientX+n.touches[1].clientX)/2,X=(n.touches[0].clientY+n.touches[1].clientY)/2,E=z-N,u=X-p,I=G.RotationFromQuaternion(i.rotation).buffer,j=new h(I[0],I[3],I[6]),ZU=new h(I[1],I[4],I[7]);Z=Z.add(j.multiply(-E*this.panSpeed*.025*c)),Z=Z.add(ZU.multiply(-u*this.panSpeed*.025*c)),N=z,p=X}else{const c=n.touches[0].clientX-N,s=n.touches[0].clientY-p;d-=c*this.orbitSpeed*.003,e+=s*this.orbitSpeed*.003,e=Math.min(Math.max(e,this.minAngle*Math.PI/180),this.maxAngle*Math.PI/180),N=n.touches[0].clientX,p=n.touches[0].clientY}},O=(n,c,s)=>(1-s)*n+s*c;this.update=()=>{if(!i)return;T=!0,t=O(t,d,this.dampening),F=O(F,e,this.dampening),V=O(V,B,this.dampening),Q=Q.lerp(Z,this.dampening);const n=Q.x+V*Math.sin(t)*Math.cos(F),c=Q.y-V*Math.sin(F),s=Q.z-V*Math.cos(t)*Math.cos(F);i.position=new h(n,c,s);const m=Q.subtract(i.position).normalize(),M=Math.asin(-m.y),z=Math.atan2(m.x,m.z);i.rotation=Y.FromEuler(new h(M,z,0));const X=.025,E=.01,u=G.RotationFromQuaternion(i.rotation).buffer,I=new h(-u[2],-u[5],-u[8]),j=new h(u[0],u[3],u[6]);J.KeyS&&(Z=Z.add(I.multiply(X))),J.KeyW&&(Z=Z.subtract(I.multiply(X))),J.KeyA&&(Z=Z.subtract(j.multiply(X))),J.KeyD&&(Z=Z.add(j.multiply(X))),J.KeyE&&(d+=E),J.KeyQ&&(d-=E),J.KeyR&&(e+=E),J.KeyF&&(e-=E),T=!1};const o=n=>{n.preventDefault(),n.stopPropagation()};this.dispose=()=>{U.removeEventListener("dragenter",o),U.removeEventListener("dragover",o),U.removeEventListener("dragleave",o),U.removeEventListener("contextmenu",o),U.removeEventListener("mousedown",C),U.removeEventListener("mousemove",v),U.removeEventListener("wheel",g),U.removeEventListener("touchstart",f),U.removeEventListener("touchend",_),U.removeEventListener("touchmove",q),R&&(window.removeEventListener("keydown",r),window.removeEventListener("keyup",S))},R&&(window.addEventListener("keydown",r),window.addEventListener("keyup",S)),U.addEventListener("dragenter",o),U.addEventListener("dragover",o),U.addEventListener("dragleave",o),U.addEventListener("contextmenu",o),U.addEventListener("mousedown",C),U.addEventListener("mousemove",v),U.addEventListener("wheel",g),U.addEventListener("touchstart",f),U.addEventListener("touchend",_),U.addEventListener("touchmove",q),this.update()}}let L=new D;const VU=new RU,A=new hU,sU=new JU(VU,A.domElement);var lU;(lU=document.getElementById("viewer"))==null||lU.appendChild(A.domElement);async function dU(b){L=new D,await WU.LoadAsync(b,L,()=>{});const l=()=>{sU.update(),A.render(L,VU),requestAnimationFrame(l)};requestAnimationFrame(l)}var tU;(tU=document.getElementById("fileSelector"))==null||tU.addEventListener("change",b=>{const l=b.target.value;dU(l)});dU("https://huggingface.co/datasets/prakashknaikade/3DGS_Results/resolve/main/taylor_swift_gsplat_extended_sh_0_cropped.splat?download=true");
